<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="面试," />





  <link rel="alternate" href="/atom.xml" title="wt" type="application/atom+xml" />






<meta name="description" content="#谈谈你对MVC的理解# ###1.概括：###    MVC是一种设计模式，这种设计模式用于分离代码的不同模块，用于提高代码的健壮性和复用性 M：modal 指的是程序的数据相关，  V：View  凡事在界面上看到的内容都是View 换句话说就是如何显示具体的内容  C：controller 如果M与V有过多的关联，那么一定会影响代码的复用性。如果要有很好的复用性，就必须让代码模块之间具备很好">
<meta name="keywords" content="面试">
<meta property="og:type" content="article">
<meta property="og:title" content="面试问题-01">
<meta property="og:url" content="https://weibo.com/wangtaoworld/面试/2015/01/24/常见面试题.html">
<meta property="og:site_name" content="wt">
<meta property="og:description" content="#谈谈你对MVC的理解# ###1.概括：###    MVC是一种设计模式，这种设计模式用于分离代码的不同模块，用于提高代码的健壮性和复用性 M：modal 指的是程序的数据相关，  V：View  凡事在界面上看到的内容都是View 换句话说就是如何显示具体的内容  C：controller 如果M与V有过多的关联，那么一定会影响代码的复用性。如果要有很好的复用性，就必须让代码模块之间具备很好">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-03-23T08:36:36.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试问题-01">
<meta name="twitter:description" content="#谈谈你对MVC的理解# ###1.概括：###    MVC是一种设计模式，这种设计模式用于分离代码的不同模块，用于提高代码的健壮性和复用性 M：modal 指的是程序的数据相关，  V：View  凡事在界面上看到的内容都是View 换句话说就是如何显示具体的内容  C：controller 如果M与V有过多的关联，那么一定会影响代码的复用性。如果要有很好的复用性，就必须让代码模块之间具备很好">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://weibo.com/wangtaoworld/面试/2015/01/24/常见面试题.html"/>





  <title>面试问题-01 | wt</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wt</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weibo.com/wangtaoworld/面试/2015/01/24/常见面试题.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangtao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wt">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试问题-01</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-24T19:26:36+08:00">
                2015-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>#谈谈你对MVC的理解#</p>
<p>###1.概括：###<br>    MVC是一种设计模式，这种设计模式用于分离代码的不同模块，用于提高代码的健壮性和复用性</p>
<pre><code>M：modal 指的是程序的数据相关，

V：View  凡事在界面上看到的内容都是View 换句话说就是如何显示具体的内容

C：controller 如果M与V有过多的关联，那么一定会影响代码的复用性。如果要有很好的复用性，就必须让代码模块之间具备很好的独立性。但是他们之间还是要有联系的。controller就是起到一个中间协调的作用，另外controller还需要处理业务逻辑，并根据业务逻辑来改变modal view
</code></pre><p>###2.讲述MVC之间的联系###<br>    M(Modal)和C(Controller)控制器可以通过Notifacation和KVO的形式对模型数据进行访问，modal不能访问控制器</p>
<pre><code>M(Modal)和C(Controller)不存在任何形式的通讯，彼此之间不能直接访问，只能通过controller控制器

V(view)和C(Controller)控制器可以直接访问view  view可以通过设置delegate，datasource，或者target(在控制器上)&lt;&lt;----action(在view上)的形式来访问控制器
</code></pre><p>##import跟#include的区别是什么?#import&lt;&gt;#import””的区别是什么？@class的作用是什么#</p>
<p>##1.#import跟#include的区别是什么?<br>    这两个指令都是预处理指令，都是在预处理阶段执行，功能都是用于包含头文件。两者的区别是:单独使用#include时，会出现重复包含头文件的问题，为了解决重复包含的问题，c语言提供了头文件卫士的预处理指令。ex:</p>
<pre><code>#ifndef XXX
#define XXX
#include&lt;XXX.h&gt;...(要包含的头文件)
#else
(要处理的其他操作)
#endif    
#import这个预处理指令，内部解决了重复包含头文件的功能，所以＃import是＃include的升级版本
</code></pre><p>##import&lt; &gt;#import” “的区别是什么？</p>
<pre><code>#import&lt;&gt;用于包含系统头文件，＃import“ ”用于包含工程内的自定义的头文件
</code></pre><p>#@class的作用是?<br>    @class的作用是前向声明，主要是当一个类，只是要知道另外一个类的描述信息，可以使用前向声明，来表达这个意思。</p>
<pre><code>使用的原因：解决文件依赖关系,依赖关系是指两个实体之间的关系，1.依赖关系可以存在于两个类之间（例如 A类继承了B类，如果B类发生了变化，例如添加了一个实例变量，那么A类就必须重新编译来适应这个变化。2.依赖关系也可以存在于两个或多个文件之间(例如：##p77明天继续##)。），
</code></pre><p>#什么是浅拷贝 什么是深拷贝<br>    my<br>    浅拷贝是：指针拷贝 不可变的数组 字典 字符串类型都是浅拷贝<br>    深拷贝：内存拷贝 可变的（Mutable）数组，字典 字符串类型都是深拷贝<br>    teacher<br>    浅拷贝相当于是仅仅拷贝了指针，新的指针指向的还是同一块内存空间，深拷贝是重新想操作系统申请了相同的内存，并把原来的数据复制一份。浅拷贝相当于对于原指针引用计数器加1 深拷贝的主要区别 主要是 重新分配内存空间 真正意义存在了两个对象。实际，深拷贝是我们一般理解的拷贝</p>
<p>#id声明的对象有什么特性<br>    id是一种通用的指针类型，可以指向任意的数据对象类型，通俗的理解，可以认为它是万能指针，他最大的特点就是具有动态特性（重点），需要注意的是使用id声明对象时，不要再添加<em>号 其本身就是一个指针，所以修饰的对象不需要指针</em>修饰</p>
<p>#声明一个属性实际上做了三件事<br>    1.声明了一个成员变量 2.声明了一个set方法 3.声明一个get方法</p>
<p>#手动管理内存基本原则是什么？在使用@property的时候，如何避免内存泄露？<br>    1.内存管理的原则：如果使用了new alloc copy方法得到了一个对象，就必须使用释放或自动释放该对象</p>
<pre><code>2.当你通过其他方法获得一个对象时，假设该对象的引用计数器是1，并且已经被设置成自动释放，那么你不需要执行任何操作来确保该对象得到清理。如果你打算在一段时间内持有该对象，则需要保留它，并在操作完成的时候释放他。

3.如果你保留了某个对象（调用retain消息），那么就必须负责释放或者自动释放这个对象，注意要保证retain和relaese的次数相等
总结：如果我使用了new alloc copy方法获得了一个对象，那我就释放或者自动释放该对象。无论什么时候拥有一个对象，有两件事必须明确，1.怎样获得该对象（alloc\new\copy 或者其他方法 ） 2 打算持有多长时间

在使用property的时候，如果用到retain copy关键字，那么在初始化的时候，不要使用点语法，如果是手动管理内存就必须重写dealloc方法，并在dealloc方法里面释放成员变量，如果在ARC的环境下，必须在dealloc方法将该成员变量指针置nil
</code></pre><p>#在iOS的平台里，出现过Nil,nil,NULL,NSNull他们分别表达的意思是什么？有什么区别<br>    my<br>    nil用于将一个实例对象置空，Nil用于将一个类置空，NULL用于将一个基本数据类型置空，NSNULL用于集合类型中，用于代表一个空对象（在集合中不允许使用nil为对象赋值，nil代表着集合的结束）<br>    teacher</p>
<pre><code>NULL定义在#include&lt;stddef.h&gt; 
#define NULL (void *)0 
所以NULL本质就是（void *）0

Nil 在系统的定义里面 
#define Nil __DARWIN_NULL
#define __DARWIN_NULL ((void *)0)
所以在oc里面 Nil的本质还是 ((void *)0)

nil的本质是 ((void *)0)

NSNull本质上就是OC中的一个类
@interface NSNull : NSObject &lt;NSCopying, NSSecureCoding&gt;
+ (NSNull *)null;
@end

NULL用于表示C语言里面的指针中的空值  
nil用于表示OC语言里面对象的空值，
Nil用于表示OC语言中类类型(class)值为空的情况
总结：
不管是NULL、nil、Nil 本质都是（void *）0 只是写法不同 这样做的意义是为了区分不同的数据类型，增强代码的可读性。举个例子：当看到一个变量赋值给NULL，就能明白这是C语言定义的指针类型，看到nil这个变量是oc的对象指针。。。。。
</code></pre><p>2014年8月29日    </p>
<h1 id="什么是类别？类别的主要作用，请列出三点"><a href="#什么是类别？类别的主要作用，请列出三点" class="headerlink" title="什么是类别？类别的主要作用，请列出三点"></a>什么是类别？类别的主要作用，请列出三点</h1><pre><code>类别是一种为现有类添加新方法的方式 它是利用OC的动态运行时分配机制，为现有的类添加新的方法
类别的主要作用
1 将类的实现代码分散到多个不同的文件或者框架中 
2 创建对私有方法的前向引用 
3 向对象添加非正式协议(实现方式：向NSObject中添加方法)
类别的缺陷
1 可以在类别中添加属性，但是属性必须是@dynamic类型，但是无法向类中添加新的实例变量，类别没有空间容纳实例变量。
2 名称冲突，也就是类别中的方法与现有的方法重名。当名称发生冲突时，类别具有更高的优先级，类别方法会完全取代初始方法（添加前缀是个解决重名的好方法）。

类扩展是一种特殊的类别 
特点：1.不需要名字 
2 可以在包含你的源代码的类(也就是你自己的类)中使用它 
3 你可以添加实例变量 
4 你可以将只读权限改成读写权限 
5 创建的数量不限 
teacher
作用：1 类别为 **已经存在** 的类添加方法，包括系统定义的类，也包括自己或者第三方定义的类
2 可以将类的实现分散到不同的文件或者多个不同的框架中实现
3 可以向对象添加非正式协议：（非正式协议：采用类别来实现的）
4 创建对私有方法的前向引用
类别的局限性：
1 无法向已存在的类中添加实例变量，因为类别没有位置容纳实例变量
2 容易造成命名冲突，根据类别的特性，通过类别向类中添加方法后会与原始的类中定义的方法重名（冲突），类别的方法优先级比原始类中的高，所以当冲突时候，类别的方法会取代原是类的方法，这样会导致错误的方法。
</code></pre><p>#内存管理<br>    对象的生命周期<br>    1 诞生（通过alloc new方法实现）<br>    2 生存（接受消息并执行操作）<br>    3 交友（通过复合以及向方法传递参数）<br>    4 死去 （被释放掉）</p>
<p>###引用计数<br>    Cocoa通过采用引用计数的方式（reference counting）每个对象都有一个与之相关联的整数，被称为引用计数器，当某段代码段需要访问一个对象时，这个代码段就将保留计数器加1 当访问结束后，将该对象的保留计数器减1.当一个对象的保留计数器归0时，OC会自动向对象发送一条dealloc消息。（注意dealloc消息不能直接调用，OC会在需要销毁对象的时候自动调用它）</p>
<pre><code>- （id）retain；（注意返回值类型是id 这样做的好处是 可以再接受其他消息的同时进行retain操作，增加对象的保留计数器的值并要求对象完成某种操作。例如 [[car retain] setTire:tire]） 表示要求car对象的保留计数器加1并执行setTire操作
- （void）release；
- （NSInterger）retainCount
</code></pre><p>###对象所有权的问题<br>    定义：如果一个对象（假设这个对象是car）内有指向其他对象的实例变量（假设是engine），则称该对象拥有这些对象。同样，如果一个函数（假设是main函数）创建了一个对象，则称该函数拥有该对象。<br>    问题：对象的所有权是谁，谁负责当对象不再使用的时候向对象发送release消息 因为car可能正在使用engine，所以不可能有main函数，也有可能main函数在随后要用到engine，所以不能是car发送release<br>    解决问题的办法：让car类保留engine对象，car类应该在setEngine:方法中保留engine对象（将其引用计数器加1 变成2）这是因为car和main两个实体都在使用engine对象，而main函数负责释放engine对象。然后当car类完成其任务后在释放engine对象（在他的dealloc方法中）最后engine被回收<br>    由此牵引出另一个问题：访问方法中的保留与释放</p>
<p>###访问方法中的保留与释放</p>
<pre><code>- （void）setEngine：（Engine *）newEngine
{
    engine = [newEngine retain];
}//bad code 
在main函数中
Engine *engine1 = [Engine new];//count = 1
[car setEngine:engine1];// count = 2
[engine1 release];//count = 1;

Engine *engine2 = [Engine new];//count = 1
[car setEngine:engine2];//count = 2
此时出现的问题是 engine1的应用计数器还是1 不能被回收 造成内存泄露
改进1
- （void）setEngine：（Engine *）newEngine
{
    [engine release];

    engine = [newEngine retain];
}//bad code 
可以修复前一个例子的问题，但是当newEngine对象和engin（原来的）是同一个对象时，会出问题
Engine *engine = [Engine new];//engine count = 1
Car *car1 = [Car new];
Car *car2 = [Car new];
[car1 setEngine:engine];//engine count = 2
[engine release];//main函数对engine对象进行释放 count = 1

[car2 setEngine:engine];//由于engine的set方法先对engine对象进行release操作，所以engine的count = 0 ，并释放掉这块内存，所以在执行下面的操作engine = [newEngine retain];会出现错误（访问了一块bad Acess）
改进2
- （void）setEngine：（newEngine）
{
    [newEngine retain];//先保留新的engine
    [engine release];//释放
    engine = newEngine;
}    //解决
上一个问题比较好解决的原因就是因为我们知道什么时候这个对象不再使用。接下来的问题是当我们不知道什么时候不在使用一个对象时怎么办
引出下一个问题：对象的自动释放
</code></pre><p>###对象的自动释放<br>    例子：</p>
<pre><code>- (NSString *)description
{
    NSString *desc;
    desc = [[NSString alloc] initWithFormat:@&quot;i am %d years old&quot;,4];
    return desc;
}
在这个例子中我们创建了一个字符串对象，但是由谁来负责销毁它呢。首先不能是description方法 因为如果先释放掉字符串对象再返回它，则保留计数器归零 对象会马上被销毁。
可以这样做
NSString *desc = [someobject description];
....//操作
[desc release]; //但是不方便  还有更好的的方法 自动释放池
</code></pre><p>###自动释放池<br>    概念：一个用来存放对象的池子（集合），当该自动释放池要被销毁时，会向池子中的所有对象发送release消息，所有的对象的引用计数器都会减一（但不一定对象会被回收）<br>    所以上面的例子可以这么写：</p>
<pre><code>- (NSString *)description
{
    NSString *desc;
    desc = [[NSString alloc] initWithFormat:@&quot;i am %d years old&quot;,4];
    return [desc autorelease];//加入到自动释放池
}
</code></pre><p>#tcp协议的三次握手 四次挥手</p>
<p>#手势识别的过程<br>    事件分发：<br>    1.首先用户触发事件,操作系统产生硬件中断响应，ios操作系统识别并捕捉到touch，motion，remote control事件，并将该事件封装成UIEvent(UIEvent 包含三种事件 touch motion remote_control(远端控制))事件，并将该事件放入到应用程序的事件队列中，该事件队列由UIApplication管理<br>    2.UIApplication对象开始管理事件队列，并从事件队列中的最上层取出事件，并分发下去处理<br>    3.分发下去的事件首先交给key window，然后key window再将事件分发给其它初始化对象<br>    4.UIWindow实例对象会首先在他的内容视图上通过调用hit-Test:WithEvent:  此方法会在其视图层次结构中的每个视图上调用pointInside:withEvent:(该方法用来判断点击事件发生的位置是否处于当前视图的范围之内，以确定用户是不是点击了当前的视图)，如果pointInside:(withEvent):方法返回YES 则继续逐级调用直到找到touch操作发生的位置 这个视图也就是要找的hit-test View<br>    hitTest:withEvent:方法处理的流程：<br>    hitTest:withEvent:方法根据已经获得的CGPOint和UIEVent事件返回hitTestView，hitTest:withEvent:方法通过调用自身的PointInside:(withEvent):方法，如果传递到hitTest:withEvent:方法中的Point在他的bounce之内，就返回YES ，然后，这个方法在每个返回YES的子视图中重复调用，直到找到最后一个在bounce内的子视图</p>
<pre><code>1 调用当前视图的PointInside:(withEvent):方法判断触摸点是否在当前视图
2 若返回NO 则hitTest:(withEvent):返回nil 说明不再当前视图
3 若返回YES 则向当前的视图的所有子视图(subViews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到最底层视图，即subViews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；
4 如果第一次有子视图返回非空对象，则hit:(withEvent:)方法返回此对象，处理结束 如果所有子视图返回非，则hitTest:(withEvent):返回自身self

处理逻辑：
根据响应者链,如果当前view是否可以处理当前事件，如果不能处理，就将事件转发给该视图的视图控制器，如果该视图控制器仍不能处理，就将该事件转发给当前视图的父视图，依次类推，如果到keyWindow事件仍然没有得到处理，那么keyWindow就将事件转发给UIApplication对象，如果仍然不能处理，就将该事件丢弃。
起始于window的初始化对象(hitTestView)，结束于UIApplication对象
所谓的响应者对象就是指可以响应并且处理事件的对象。响应者链就是一系列的响应者对象构成的一个层次结构
第一响应者指的就是当前正在响应事件的对象。
</code></pre><p>#方法签名<br>    方法在声明的时候，方法的名字。<br>    button有3种方法签名<br>    1 没有参数 2 有一个参数UIButton 3 有两个参数 UIButton和 触发事件 参数<br>    手势有两种事件签名<br>    1 没有参数 2 有一个UIGestureRecognizer类型的参数</p>
<p>#main函数的作用<br>    main函数是程序的启动入口，在ios app中，main函数的功能被最小化，他的主要工作交给了UIKit framework</p>
<pre><code>#import &lt;UIKit/UIKit.h&gt;
#import &quot;QYAppDelegate.h&quot;
int main(int argc, char * argv[])
{
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([QYAppDelegate class]));
    }
}
在main函数里面执行了一个UIApplicationMain函数。
argc, argv,直接交给UIapplicationMain进行相关处理即可。第三个参数确定主要应用程序类的名称，如果这个参数是nil，这样就会使用UIApplication类创建对象。第四个参数是程序自定义的代理类名
理解：UIApplicationMain的三件事：
1 根据第三个参数创建UIApplication对象 
2 根据第四个参数确定应用程序的delegate 
3 设置主事件循环(main event loop 可以认为这是一个死循环，他不断的检测事件队列中是否有事件需要处理，当他监听到系统事件时，就会通知UIApplication对象的代理delegate对象)包括application的run loop，同时开始处理事件 当程序加载完毕后调用（只调用一次）application：didFinishLaunchingWithOption:方法。
</code></pre><p>#UIWindow<br>    UIWindow是一种特殊的UIView，通常一个app中只有UIWindow，ios程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的view 最后将控制器的view添加到UIWindow 于是控制器的view就显示屏幕上。也就是说，没有UIWindow，就看不到UI界面<br>    UIWindow的获得：<br>    1 [UIApplication shardApplication].windows 在本应用中打开UIWindow列表，这样就可以接触到应用中的任何一个UIView对象<br>    2 [UIApplication shardApplication].keyWindow 用来接受键盘以及非接触类的消息事件的UIWindow 应用程序中每个时刻只能有一个UIWindow是keyWindow 如果某个UIWindow内部文本框不能输入文字，可能就是这个UIwindow不是keyWindow<br>    3 view.window 获得某个UIView所在的UIWindow<br>    storyBoard加载时<br>    1 会自动创建一个UIWindow对象，<br>    2 加载Main storyBoard 创建箭头所指的视图控制器<br>    3 并将storyBoard箭头所指的控制器设为rootController，并将窗口显示在屏幕上</p>
<p>#UIApplication<br>    UIApplication 对象是应用程序的象征，并且是单例的 [UIApp;icatin shardApplication]可以获得这个单例对象 这个是ios程序启动后创建的第一个对象 并且不允许自己创建该对象<br>    利用UIApplication对象，可以进行一些应用级别的操作<br>    1 设置联网指示器的可见 networkActivityIndicationVisible<br>    2 设置应用程序图标右上角的红色提示数字 applicationIconBadgeNumber(0 代表清除图标右上角的数字)<br>    3 在ios7开始 系统提供了2中管理状态栏的方式 1 通过UIViewController管理 每个UIViewController都可以拥有一个自己的不同的状态栏 2 通过UIApplication管理 一个应用程序的状态栏由他统一管理。<br>    默认的情况下，状态栏都是由UIViewController管理   - （BOOl）preferStatusBarHidden 状态栏的可见性<br>    如果要利用UIApplication来管理状态栏 首先修改info.plist文件<br>    加上row （View controller-based status bar appearance BOOL NO）<br>    4 UIApplication有一个功能十分强大 openURL：方法<br>    UIApplication *app = [UIApplication shardAppliaction];<br>    [app openURL:[NSURL URLWithString:@”tel://10086”]];//打电话<br>    [app openURL:[NSURL URLWithString:@”sms://10086”]];//发短信<br>    [app openURL:[NSURL URLWithString:@”mailto:<a href="mailto://1235@qq.com" target="_blank" rel="noopener">//1235@qq.com</a>“]];//发邮件<br>    [app openURL:[NSURL URLWithStrinf:@”<a href="http://www.baidu.com&quot;]]" target="_blank" rel="noopener">http://www.baidu.com&quot;]]</a>;<br>    打开其他应用app</p>
<p>#程序启动的完整过程<br>    1 首先执行main函数<br>    2 在main函数中调用UIApplication Main函数<br>        创建UIApplication对象<br>        创建UIApplication的Delegate对象<br>    3 delegate对象开始监听系统事件（在非storyBoard的情况下）<br>        1 程序启动完毕后，就会调用代理的<br>        2 application:(UIApplication <em>) didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法<br>        在这个方法中创建UIWindow和rootViewController对象<br>        3 显示窗口<br>    3 根据info.plist获得最主要的storyBoard的文件名，加载最主要的storyboard<br>        1 创建UIWindow<br>        2 创建和设置UIwindow的rootViewController<br>        3 显示窗口</p>
<p>##UIApplication，UIApplication的代理MKDelegate对象，UIWindow，UIViewController之间的关系<br>    UIApplication对象内部有一个代理属性 关联到MKDelegate对象,MKDelegate里面有一个UIwindow属性，关联到UIWindow对象<br>    UIWindow对象通过设置rootViewController属性关联到UIViewController对象，UIViewController的View属性用于显示视图</p>
<p>#退出键盘方法<br>    老方法：谁把键盘叫出来，谁就把键盘放回去<br>    新方法：调用[self.view endEditing:YES]方法 是整个View都不是第一响应者</p>
<p>#info.plist，pch文件 infoPList.string文件<br>    info.plist文件是对整个工程做一些运行期的配置，不能删除，所以在自定义的plist文件命名不能以plist开头，如果修改了info.plist文件，需要先把工程clean 然后再把模拟器中的应用删除<br>    infoPlist.string文件用于本地化 支持对语言环境</p>
<pre><code>pch文件是一个头文件 pch头文件中的内容可以被项目中的其他所有的源文件共享和访问  

作用 1 可以用于存放全局变量（整个项目都用得上的宏） 
2 如果某个头文件要在整个项目中到处使用，可以在pch文件中包含
eg 在pch文件中添加 #define MKLog(...) NSLog(__AV_ARGS__)(固定写法)用MKLog代替NSLog
当改为 #define MKLog(...) //NSLog(__) NSLog(__AV_ARGS__) 相当于把所有的MKLog注释了
3 自动打开后者关闭日志输出功能
应用程序可分为调试阶段和发布阶段，在调试阶段系统（通过检测程序的运行是在真机设配还是模拟器(或者Xcode环境)）会自定义一个叫做DEBUG的宏，当处于发布阶段的时候，DEBUG这个宏会由系统自动删除
#ifdef DEBUG//调试阶段 //很有用
#define MKLog(...) NSLog(__AV_ARGS__)
#else //发布阶段
#define MKLog(...)
#endif
******************************
#ifdef __OBJC__//只有OC文件中的.m 和 .mm 才能使用 __OBJC__这个宏表示只有OC才能使用 所以OC文件里面使用的宏要放在这个宏里面
#import &lt;UIKit/UIKit.h&gt;
#import &lt;Foundation/Foundation.h&gt;
#endif
</code></pre><p>#谓词 predicate<br>    在编程中，经常需要获取一个对象的集合，并通过某些已知条件计算这个集合的值，并保留某些符合条件的对象，删除不满足的条件的对象。 NSPredicate是一种过滤条件,用于指定过滤器的条件。通过创建NSPredicate对象，准确的描述过滤条件，通过谓词筛选对象，判断他们是否于过滤条件匹配<br>    方便1 数组过滤器：通过这种方式不必编写for循环和if语句  -filteredArrayUsingPredicate:是NSArray NSMutableArray数组中的一种类别方法，他将循环遍历数组内容，根据谓词计算每个对象的值，并将值为YES的对象累计添加到一个新数组中。缺点：运行速度没有自己写的代码快<br>    解决谓词中的硬编码问题：方法一：格式说明符 方法2：变量名<br>    predict = [NSPredicate predicateWithFormat:@”engine.horsepower &gt; %d”,50];<br>    predict = [NSPredicate predicateWithFormat:@”name == %@”,@”herbie”]; 通过传参<br>    predict = [NSPredicate predicateWithFormat:@”%K==%@”,@name,@”Herbie”];//改变键路径 只能通过%K的格式符改变键路径<br>    2<br>    predictTemplate = [NSPredicate predicateWithFormat:@”name = $NAME”];<br>    NSDictionary *dict = @{@”NAME”:@”heibie”}<br>    predicate = [predicateTemPlate predicateWithSubstitleVariables:dict];//返回一个新的谓词对象</p>
<p>#正则表达式<br>    正则表达式以用^表示开始 $表示结束 以一个[A-Za-z0-9_+-]表示匹配一个字符 {8}表示匹配8个字符<br>    | 竖直分隔符代表选择。例如“gray|grey”可以匹配grey或gray。</p>
<pre><code>+ 加号代表前面的字符必须至少出现一次。(1次、或多次)。例如,“goo+gle”可以匹 配google、gooogle、goooogle等
? 问号代表前面的字符最多只可以出现一次。(0次、或1次)。例如,“colou?r”可以匹 配color或者colour
* 星号代表前面的字符可以不出现,也可以出现一次或者多次。(0次、或1次、或多 次)。例如,“0*42”可以匹配42、042、0042、00042等。
{n}重复n此
{n,}至少重复 n 此
{n,m}重n 到 m 此
</code></pre><p>#kvc kvo<br>    KVC (key value coding) 是一种协议,(属性的点或者设置实例变量来 直接 更改对象的状态)是一种 间接 更改对象状态的方式.它实现的方法就是使用字符串表示更改的对象状态,如果找不到会调用undefined方法.</p>
<pre><code>KVO 提供了一种机制,当制定对象的属性发生改变后,则对象就会接收到通知,简单的说就是每次指定的被观察的对象的属性被修改后, KVO 就会自动通知相应观察者.
注意:必须使用 set 方法,或者 KVC 的方法修改属性的值,才会引起 KVO 的通知
KVO 是 model 于 controller 之间通信的一种机制.controller 作为观察者,监听 modal 某一属性的改变.
KVO 于 notification 的区别和联系
相同:均可以实现 modal 和 controller 之间的通信
区别: KVO 直接通知 controller, 模型数据的变化,前提是 controller 已经是 modal 的观察者
优点:只通知一个属性的改变,并且属性的改变是由系统通知给 controller, 模型对象不需要发送 post 通知,效率更高,力度更消耗资源更少
notification 可以实现连个对象之间的通信
1 需要通知中心 ,间接地通知 controller, 只要注册即可,
2 如果 modal 发生改变,需要 modal 自己向通知中心发送(调用post方法)通知,再有通知中心再向 controller(前提是已经向通知中心注册) 发送,这个过程力度较大,会通知所有改变
通知(notification 和代理 delegate 的区别)
相同:都能完成对象之间的通信
代理是一对一的(一个对象对应于另外一个对象,并且一个对象只能告诉另外一个对象发生什么事情(单向通信)),通知是多对多的关系(一个对象(通知发布者)可以对应于多个观察者(通知接受者),同时每个观察对象可以同时观察多个对象  )
</code></pre><p>#XML解析<br>    XML 被设计用来结构化(基于树形结构(很重要)),存储以及传输信息,它没有任何行为,不能显示任何信息,区分于HTML<br>    使用 XML json 的目的是为了跨平台<br>    SAX(simple APIs for XML)提供了一种 顺序访问模式 ，当使用SAX分析器解析XML文档进行分析时，会触发一系列的事件，并激活相应的事件处理函数。应用程序通过对这些事件处理函数来实现对XML文件的解析。所以SAX也被成为  事件驱动  接口。由于SAX在对XML文件解析时会触发一系列的处理函数，由于事件触发本身是有时序性的，因此，SAX是一种顺序访问机制，对于已经访问过的部分，不能再倒回去重新工作。SAX在实现时，只是在顺序的检查XML文档中的字节流，判断当前字节是XML语法中的那一部分，是否符合XML语法，再触发相应的事件，事件的处理函数由应用程序自己实现<br>    使用NSXMLParser<br>    优点：对内存占用的少，实现简单，对只需要访问XML文档中的数据而不对文档进行更改的应用程序来说很合适<br>     缺点：缺少灵活性,，效率较低<br>    DOM(document object modal) 文件解析 是利用第三方库GDataXMLNode.h GDataXMLNode.m 在使用第三库的时候在使用DOMXML解析文件是设置一下几项<br>    1 在Header Search Paths 加上/usr/include/libxml2<br>    2 在build Phases中的GCDataXMLNode.m 加上-fno-objc-arc<br>    3 other linkFlag 添上 -lxml2(一套开源的解析框架)<br>    一次性将 XML 文档读入到内存中,并以树形结构存在,可以随意访问任何一个元素<br>    缺点：占用的内存较多</p>
<p>#json<br>    json (javascript object notation)javaScript对象表示法 是轻量级的文本数据交换格式，独立于语言，具有自我描述性，易理解 独立于语言和平台 比XML相比的优点：没有结束标签 更短 读写速度更快 使用数组 不使用保留字,网络数据量消耗小<br>    缺点:可读性差,编码难度大<br>    两种框架<br>    1 NSJsonSerialization ios5.0之后有效<br>    2 jsonKit </p>
<p>#web 服务器<br>    web 服务器也被称为 www服务器,主要功能是可以向发出请求的浏览器提供文档程序.<br>    服务器是一种被动程序,只有当 Internet 上运行其他计算机的浏览器发出请求时,服务器才会响应,常用的服务器有 IIS 和 Apache .<br>    web 服务器是一台在 Internet 上具有独立的 ip 地址的计算机<br>    web 服务器是指驻留在因特网上的某种类型计算机的程序<br>    在 MAC 启动本地的 Apache 服务器 sudo apachectl -k start 重新启动: sudo apachectl -k restart</p>
<p>#post&amp;get<br>    post 和 get 是两种最常用的与服务器进行交互的 HTTP 方法<br>    get 的语义是 获取 指定的URL的资源<br>    将数据按照 variable =value 的形式,添加到 action 所指的 URL 后面,并且两者之间使用?连接,各变量之间使用&amp;连接<br>    缺点:<br>    1 貌似不安全,因为在传输的过程中,数据将被放在请求的 URL 中<br>    2 传输的数据量小,这主要是因为受 URL 的长度限制<br>    post:<br>    post 的语义是 向指定的URL的资源 添加 数据<br>    将数据放在数据体中,按照变量和值向对应的方式,传递到 action 所指向的 URL<br>    优点<br>    1 所有的数据对用户来说都是不可见的<br>    2 可以传输大量数据,上传文件只能是 post<br>    总结:如果从 URL 的角度看的话: get方法是不安全的, post方法是安全的,因为get在传输过程中,数据都放在URL中,但是如果从服务器的角度上讲, get方法是安全的, post方法是不安全的,因为 post方法回向服务器添加数据,而 get 方法只会向服务器获取数据,所以,如果要想服务器进行攻击,只能使用 post 方法</p>
<p>#block<br>    (返回值类型)(^块名字)(参数类型) = ^(参数列表){代码实现};<br>    block 是一种特殊的数据类型,可以将 block 当做比较特殊的对象</p>
<h3 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h3><pre><code>block 可以使用在定义之前声明的局部变量(默认的情况下是只读的)
int i = 10;
void (^myblock)() = ^{
    NSLog(&quot;%d&quot;,i);
};
i = 100;
myblock();
输出结果是 10 
注意:
1 在定义 block 时 ,会在 block 中建立  当前局部变量内容的副本(拷贝), block 中所用的也就是这个副本
2 后续在对该变量的的任何修改,都不会影响 block 中的这个变量的数值
3 如果需要在 block 中保持局部变量的数值变化,需要使用__ block 关键字
4 使用__block 关键字之后,同样可以再 block 中修改变量数值
</code></pre><p>###传递对象</p>
<p>###注意循环引用<br>    @property (nonatomic, strong) NSMutableArray *myBlocks;</p>
<pre><code>#pragma mark 将代码改为调用self的方法
int(^sum)(int, int) = ^(int x, int y) {
    return [self sum:x y:y];
};
[self.myBlocks addObject:sum];

#pragma mark 对象被释放时自动调用
- (void)dealloc
{
    NSLog(@&quot;DemoObj被释放&quot;);
}
self 对 myblocks 强引用 myblock 对sum 强引用 sum 对 self 强引用 产生循环引用的结果就是对象无法释放,由于局部变量默认的都是强引用,离开其所在的作用区域后都会被释放.所以使用__ weak关键字,将局部变量声明为弱引用
__weak DemoObj *weakSelf = self;
int (^int,int) = ^(int,int){
    return [weakSelf sum:x y:y];
};
所以在 block 内部,如果碰到 self, 最好能够思考一下,不要造成循环引用
</code></pre><p>#进程 线程<br>    进程作为分配资源的基本单位,<br>    线程是独立运行和独立调度(有操作系统内核调度)的基本单位.</p>
<p>###进程:<br>    正在运行中的程序,负责程序运行的内存分配,每一个进程都有一个自己独立的虚拟内存空间,进程是一个基本的分配单元,也是一个基本的执行单元,相比较程序,进程是一个动态概念,进程是程序在处理机上的一个执行过程,而程序是一种静态概念,它是一种软件资料在外存上长期有效<br>    要点:<br>    1 进程是一个实体,每个进程都有一个他自己的地址空间,一般情况下,包含数据区域,文本区域,堆和栈.<br>    文本区域存储处理器执行的代码;<br>    数据段存储全局变量,静态变量常亮,还有一些进程执行期间使用的动态分配内存<br>    堆栈区域存储的是进程调用的指令和本地变量<br>    2 进程是一个在内存中运行的程序<br>    进程的缺点:独立的地址造成不同的进程之间的共享状态信息非常困难,为了共享信息,必须显式的使用进程通信机制系统的开销很大, 这就造成了进程之间的通信比较慢,</p>
<p>###线程:<br>    是进程中一个独立的执行路径(控制单元),一个进程中至少包含一个线程,即主线程,通常将耗时的执行路径:eg:网络请求放在其他线程执行.<br>    创建线程的目的就是为了开启一条新的执行路径(在进程中开辟了一个上下文的逻辑流),运行指定的代码,与主线程的代码实现并发运行<br>    多线程优势:<br>    1 充分发挥多核处理器的优势,将不同的线程分配给不同的处理器,<br>    2 将耗时操作分配到其他线程执行,由主线程负责统一更新界面会使程序更加流畅<br>    3 当硬件处理器的数量增加时,程序会运行更快<br>    4 占用的资源很少,所以对他的调度付出的系统开销很小,能跟高效的提高提高系统内多个程序间的并发执行速度<br>    缺点:新建线程会消耗内存空间和 CPU 时间,降低系统性能,多线程技术是为了并发执行多项任务,不会提高单个算法本身的执行效率</p>
<p>###ios 三种多线程技术<br>    1 NSThread (创建简单,管理困难,常使用[NSThread currentThread]跟踪任务所在线程)<br>    2 NSOperation/NSOperationQueue (是使用 GCD 实现的一套 OC 的 API)<br>    3 GCD(Grand Central Dispatch 大中心调度,基于C语言的底层API,用block定义任务,方便,提供了更多的控制能力以及操作队列中不能使用的底层函数)  </p>
<p>#git<br>    git init –bare 创建一个纯代码仓库<br>    git clone ssh:<a href="mailto://git@192.168.1.122" target="_blank" rel="noopener">//git@192.168.1.122</a>/Users/git/Documents/test<br>    git push ssh:<a href="mailto://git@192.168.1.122" target="_blank" rel="noopener">//git@192.168.1.122</a>/Users/git/Documents/test master<br>    git pull </p>
<p>#@property属性的用法<br>    weak(assign):代理\ UI控件<br>    strong(retain)其他对象(除代理\UI控件\字符串)<br>    copy (字符串)<br>    assign 基本数据类型(int float 枚举 结构体 BOOL)</p>
<p>#比较常用的程序架构<br>    当首次使用软件的时候,需要登录为例:<br>        1 下载完成后,运行,先弹出的是用户指引界面,一般式 UIScrollView 和 UIImageView 结合实现,当 UIScrollView 滑动到最后一个界面,通常有一个按钮,点击按钮后进入到登录页面,填写完用户名和密码后,进入主界面<br>        当不是第一次运行APP 的时候,在屏幕上点击 ICNO 图标时,如果记住密码,就直接进入程序主界面,如果没有记住密码的时候,则会重新弹出登录界面,要求用户输入用户名和密码,然后进入主界面.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/uncategorized/2015/01/17/iOS开发/viewController.html" rel="next" title="viewController">
                <i class="fa fa-chevron-left"></i> viewController
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/uncategorized/2018/03/20/GitHub博客/hello-world.html" rel="prev" title="Hello World">
                Hello World <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wangtao</p>
              <p class="site-description motion-element" itemprop="description">技术交流</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是类别？类别的主要作用，请列出三点"><span class="nav-number">1.</span> <span class="nav-text">什么是类别？类别的主要作用，请列出三点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用局部变量"><span class="nav-number">1.0.1.</span> <span class="nav-text">使用局部变量</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangtao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
