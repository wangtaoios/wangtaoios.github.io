<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="wt" type="application/atom+xml" />






<meta name="description" content="技术交流">
<meta property="og:type" content="website">
<meta property="og:title" content="wt">
<meta property="og:url" content="https://weibo.com/wangtaoworld/index.html">
<meta property="og:site_name" content="wt">
<meta property="og:description" content="技术交流">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wt">
<meta name="twitter:description" content="技术交流">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://weibo.com/wangtaoworld/"/>





  <title>wt</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wt</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weibo.com/wangtaoworld/iOS/2018/03/20/test1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangtao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wt">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/iOS/2018/03/20/test1.html" itemprop="url">test</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T14:33:30+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSString<br>字符串</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weibo.com/wangtaoworld/uncategorized/2018/03/20/hello-world.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangtao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wt">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/2018/03/20/hello-world.html" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T14:31:08+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weibo.com/wangtaoworld/uncategorized/2015/01/24/常见面试题.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangtao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wt">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/2015/01/24/常见面试题.html" itemprop="url">1124</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-24T19:26:36+08:00">
                2015-01-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#2015-01-21#</p>
<p>#谈谈你对MVC的理解#</p>
<p>###1.概括：###<br>    MVC是一种设计模式，这种设计模式用于分离代码的不同模块，用于提高代码的健壮性和复用性</p>
<pre><code>M：modal 指的是程序的数据相关，

V：View  凡事在界面上看到的内容都是View 换句话说就是如何显示具体的内容

C：controller 如果M与V有过多的关联，那么一定会影响代码的复用性。如果要有很好的复用性，就必须让代码模块之间具备很好的独立性。但是他们之间还是要有联系的。controller就是起到一个中间协调的作用，另外controller还需要处理业务逻辑，并根据业务逻辑来改变modal view
</code></pre><p>###2.讲述MVC之间的联系###<br>    M(Modal)和C(Controller)控制器可以通过Notifacation和KVO的形式对模型数据进行访问，modal不能访问控制器</p>
<pre><code>M(Modal)和C(Controller)不存在任何形式的通讯，彼此之间不能直接访问，只能通过controller控制器

V(view)和C(Controller)控制器可以直接访问view  view可以通过设置delegate，datasource，或者target(在控制器上)&lt;&lt;----action(在view上)的形式来访问控制器
</code></pre><p>##import跟#include的区别是什么?#import&lt;&gt;#import””的区别是什么？@class的作用是什么#</p>
<p>##1.#import跟#include的区别是什么?<br>    这两个指令都是预处理指令，都是在预处理阶段执行，功能都是用于包含头文件。两者的区别是:单独使用#include时，会出现重复包含头文件的问题，为了解决重复包含的问题，c语言提供了头文件卫士的预处理指令。ex:</p>
<pre><code>#ifndef XXX
#define XXX
#include&lt;XXX.h&gt;...(要包含的头文件)
#else
(要处理的其他操作)
#endif    
#import这个预处理指令，内部解决了重复包含头文件的功能，所以＃import是＃include的升级版本
</code></pre><p>##import&lt; &gt;#import” “的区别是什么？</p>
<pre><code>#import&lt;&gt;用于包含系统头文件，＃import“ ”用于包含工程内的自定义的头文件
</code></pre><p>#@class的作用是?<br>    @class的作用是前向声明，主要是当一个类，只是要知道另外一个类的描述信息，可以使用前向声明，来表达这个意思。</p>
<pre><code>使用的原因：解决文件依赖关系,依赖关系是指两个实体之间的关系，1.依赖关系可以存在于两个类之间（例如 A类继承了B类，如果B类发生了变化，例如添加了一个实例变量，那么A类就必须重新编译来适应这个变化。2.依赖关系也可以存在于两个或多个文件之间(例如：##p77明天继续##)。），
</code></pre><p>#什么是浅拷贝 什么是深拷贝<br>    my<br>    浅拷贝是：指针拷贝 不可变的数组 字典 字符串类型都是浅拷贝<br>    深拷贝：内存拷贝 可变的（Mutable）数组，字典 字符串类型都是深拷贝<br>    teacher<br>    浅拷贝相当于是仅仅拷贝了指针，新的指针指向的还是同一块内存空间，深拷贝是重新想操作系统申请了相同的内存，并把原来的数据复制一份。浅拷贝相当于对于原指针引用计数器加1 深拷贝的主要区别 主要是 重新分配内存空间 真正意义存在了两个对象。实际，深拷贝是我们一般理解的拷贝</p>
<p>#id声明的对象有什么特性<br>    id是一种通用的指针类型，可以指向任意的数据对象类型，通俗的理解，可以认为它是万能指针，他最大的特点就是具有动态特性（重点），需要注意的是使用id声明对象时，不要再添加<em>号 其本身就是一个指针，所以修饰的对象不需要指针</em>修饰</p>
<p>#声明一个属性实际上做了三件事<br>    1.声明了一个成员变量 2.声明了一个set方法 3.声明一个get方法</p>
<p>#手动管理内存基本原则是什么？在使用@property的时候，如何避免内存泄露？<br>    1.内存管理的原则：如果使用了new alloc copy方法得到了一个对象，就必须使用释放或自动释放该对象</p>
<pre><code>2.当你通过其他方法获得一个对象时，假设该对象的引用计数器是1，并且已经被设置成自动释放，那么你不需要执行任何操作来确保该对象得到清理。如果你打算在一段时间内持有该对象，则需要保留它，并在操作完成的时候释放他。

3.如果你保留了某个对象（调用retain消息），那么就必须负责释放或者自动释放这个对象，注意要保证retain和relaese的次数相等
总结：如果我使用了new alloc copy方法获得了一个对象，那我就释放或者自动释放该对象。无论什么时候拥有一个对象，有两件事必须明确，1.怎样获得该对象（alloc\new\copy 或者其他方法 ） 2 打算持有多长时间

在使用property的时候，如果用到retain copy关键字，那么在初始化的时候，不要使用点语法，如果是手动管理内存就必须重写dealloc方法，并在dealloc方法里面释放成员变量，如果在ARC的环境下，必须在dealloc方法将该成员变量指针置nil
</code></pre><p>#在iOS的平台里，出现过Nil,nil,NULL,NSNull他们分别表达的意思是什么？有什么区别<br>    my<br>    nil用于将一个实例对象置空，Nil用于将一个类置空，NULL用于将一个基本数据类型置空，NSNULL用于集合类型中，用于代表一个空对象（在集合中不允许使用nil为对象赋值，nil代表着集合的结束）<br>    teacher</p>
<pre><code>NULL定义在#include&lt;stddef.h&gt; 
#define NULL (void *)0 
所以NULL本质就是（void *）0

Nil 在系统的定义里面 
#define Nil __DARWIN_NULL
#define __DARWIN_NULL ((void *)0)
所以在oc里面 Nil的本质还是 ((void *)0)

nil的本质是 ((void *)0)

NSNull本质上就是OC中的一个类
@interface NSNull : NSObject &lt;NSCopying, NSSecureCoding&gt;
+ (NSNull *)null;
@end

NULL用于表示C语言里面的指针中的空值  
nil用于表示OC语言里面对象的空值，
Nil用于表示OC语言中类类型(class)值为空的情况
总结：
不管是NULL、nil、Nil 本质都是（void *）0 只是写法不同 这样做的意义是为了区分不同的数据类型，增强代码的可读性。举个例子：当看到一个变量赋值给NULL，就能明白这是C语言定义的指针类型，看到nil这个变量是oc的对象指针。。。。。
</code></pre><p>2014年8月29日    </p>
<h1 id="什么是类别？类别的主要作用，请列出三点"><a href="#什么是类别？类别的主要作用，请列出三点" class="headerlink" title="什么是类别？类别的主要作用，请列出三点"></a>什么是类别？类别的主要作用，请列出三点</h1><pre><code>类别是一种为现有类添加新方法的方式 它是利用OC的动态运行时分配机制，为现有的类添加新的方法
类别的主要作用
1 将类的实现代码分散到多个不同的文件或者框架中 
2 创建对私有方法的前向引用 
3 向对象添加非正式协议(实现方式：向NSObject中添加方法)
类别的缺陷
1 可以在类别中添加属性，但是属性必须是@dynamic类型，但是无法向类中添加新的实例变量，类别没有空间容纳实例变量。
2 名称冲突，也就是类别中的方法与现有的方法重名。当名称发生冲突时，类别具有更高的优先级，类别方法会完全取代初始方法（添加前缀是个解决重名的好方法）。

类扩展是一种特殊的类别 
特点：1.不需要名字 
2 可以在包含你的源代码的类(也就是你自己的类)中使用它 
3 你可以添加实例变量 
4 你可以将只读权限改成读写权限 
5 创建的数量不限 
teacher
作用：1 类别为 **已经存在** 的类添加方法，包括系统定义的类，也包括自己或者第三方定义的类
2 可以将类的实现分散到不同的文件或者多个不同的框架中实现
3 可以向对象添加非正式协议：（非正式协议：采用类别来实现的）
4 创建对私有方法的前向引用
类别的局限性：
1 无法向已存在的类中添加实例变量，因为类别没有位置容纳实例变量
2 容易造成命名冲突，根据类别的特性，通过类别向类中添加方法后会与原始的类中定义的方法重名（冲突），类别的方法优先级比原始类中的高，所以当冲突时候，类别的方法会取代原是类的方法，这样会导致错误的方法。
</code></pre><p>#内存管理<br>    对象的生命周期<br>    1 诞生（通过alloc new方法实现）<br>    2 生存（接受消息并执行操作）<br>    3 交友（通过复合以及向方法传递参数）<br>    4 死去 （被释放掉）</p>
<p>###引用计数<br>    Cocoa通过采用引用计数的方式（reference counting）每个对象都有一个与之相关联的整数，被称为引用计数器，当某段代码段需要访问一个对象时，这个代码段就将保留计数器加1 当访问结束后，将该对象的保留计数器减1.当一个对象的保留计数器归0时，OC会自动向对象发送一条dealloc消息。（注意dealloc消息不能直接调用，OC会在需要销毁对象的时候自动调用它）</p>
<pre><code>- （id）retain；（注意返回值类型是id 这样做的好处是 可以再接受其他消息的同时进行retain操作，增加对象的保留计数器的值并要求对象完成某种操作。例如 [[car retain] setTire:tire]） 表示要求car对象的保留计数器加1并执行setTire操作
- （void）release；
- （NSInterger）retainCount
</code></pre><p>###对象所有权的问题<br>    定义：如果一个对象（假设这个对象是car）内有指向其他对象的实例变量（假设是engine），则称该对象拥有这些对象。同样，如果一个函数（假设是main函数）创建了一个对象，则称该函数拥有该对象。<br>    问题：对象的所有权是谁，谁负责当对象不再使用的时候向对象发送release消息 因为car可能正在使用engine，所以不可能有main函数，也有可能main函数在随后要用到engine，所以不能是car发送release<br>    解决问题的办法：让car类保留engine对象，car类应该在setEngine:方法中保留engine对象（将其引用计数器加1 变成2）这是因为car和main两个实体都在使用engine对象，而main函数负责释放engine对象。然后当car类完成其任务后在释放engine对象（在他的dealloc方法中）最后engine被回收<br>    由此牵引出另一个问题：访问方法中的保留与释放</p>
<p>###访问方法中的保留与释放</p>
<pre><code>- （void）setEngine：（Engine *）newEngine
{
    engine = [newEngine retain];
}//bad code 
在main函数中
Engine *engine1 = [Engine new];//count = 1
[car setEngine:engine1];// count = 2
[engine1 release];//count = 1;

Engine *engine2 = [Engine new];//count = 1
[car setEngine:engine2];//count = 2
此时出现的问题是 engine1的应用计数器还是1 不能被回收 造成内存泄露
改进1
- （void）setEngine：（Engine *）newEngine
{
    [engine release];

    engine = [newEngine retain];
}//bad code 
可以修复前一个例子的问题，但是当newEngine对象和engin（原来的）是同一个对象时，会出问题
Engine *engine = [Engine new];//engine count = 1
Car *car1 = [Car new];
Car *car2 = [Car new];
[car1 setEngine:engine];//engine count = 2
[engine release];//main函数对engine对象进行释放 count = 1

[car2 setEngine:engine];//由于engine的set方法先对engine对象进行release操作，所以engine的count = 0 ，并释放掉这块内存，所以在执行下面的操作engine = [newEngine retain];会出现错误（访问了一块bad Acess）
改进2
- （void）setEngine：（newEngine）
{
    [newEngine retain];//先保留新的engine
    [engine release];//释放
    engine = newEngine;
}    //解决
上一个问题比较好解决的原因就是因为我们知道什么时候这个对象不再使用。接下来的问题是当我们不知道什么时候不在使用一个对象时怎么办
引出下一个问题：对象的自动释放
</code></pre><p>###对象的自动释放<br>    例子：</p>
<pre><code>- (NSString *)description
{
    NSString *desc;
    desc = [[NSString alloc] initWithFormat:@&quot;i am %d years old&quot;,4];
    return desc;
}
在这个例子中我们创建了一个字符串对象，但是由谁来负责销毁它呢。首先不能是description方法 因为如果先释放掉字符串对象再返回它，则保留计数器归零 对象会马上被销毁。
可以这样做
NSString *desc = [someobject description];
....//操作
[desc release]; //但是不方便  还有更好的的方法 自动释放池
</code></pre><p>###自动释放池<br>    概念：一个用来存放对象的池子（集合），当该自动释放池要被销毁时，会向池子中的所有对象发送release消息，所有的对象的引用计数器都会减一（但不一定对象会被回收）<br>    所以上面的例子可以这么写：</p>
<pre><code>- (NSString *)description
{
    NSString *desc;
    desc = [[NSString alloc] initWithFormat:@&quot;i am %d years old&quot;,4];
    return [desc autorelease];//加入到自动释放池
}
</code></pre><p>#tcp协议的三次握手 四次挥手</p>
<p>#手势识别的过程<br>    事件分发：<br>    1.首先用户触发事件,操作系统产生硬件中断响应，ios操作系统识别并捕捉到touch，motion，remote control事件，并将该事件封装成UIEvent(UIEvent 包含三种事件 touch motion remote_control(远端控制))事件，并将该事件放入到应用程序的事件队列中，该事件队列由UIApplication管理<br>    2.UIApplication对象开始管理事件队列，并从事件队列中的最上层取出事件，并分发下去处理<br>    3.分发下去的事件首先交给key window，然后key window再将事件分发给其它初始化对象<br>    4.UIWindow实例对象会首先在他的内容视图上通过调用hit-Test:WithEvent:  此方法会在其视图层次结构中的每个视图上调用pointInside:withEvent:(该方法用来判断点击事件发生的位置是否处于当前视图的范围之内，以确定用户是不是点击了当前的视图)，如果pointInside:(withEvent):方法返回YES 则继续逐级调用直到找到touch操作发生的位置 这个视图也就是要找的hit-test View<br>    hitTest:withEvent:方法处理的流程：<br>    hitTest:withEvent:方法根据已经获得的CGPOint和UIEVent事件返回hitTestView，hitTest:withEvent:方法通过调用自身的PointInside:(withEvent):方法，如果传递到hitTest:withEvent:方法中的Point在他的bounce之内，就返回YES ，然后，这个方法在每个返回YES的子视图中重复调用，直到找到最后一个在bounce内的子视图</p>
<pre><code>1 调用当前视图的PointInside:(withEvent):方法判断触摸点是否在当前视图
2 若返回NO 则hitTest:(withEvent):返回nil 说明不再当前视图
3 若返回YES 则向当前的视图的所有子视图(subViews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到最底层视图，即subViews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；
4 如果第一次有子视图返回非空对象，则hit:(withEvent:)方法返回此对象，处理结束 如果所有子视图返回非，则hitTest:(withEvent):返回自身self

处理逻辑：
根据响应者链,如果当前view是否可以处理当前事件，如果不能处理，就将事件转发给该视图的视图控制器，如果该视图控制器仍不能处理，就将该事件转发给当前视图的父视图，依次类推，如果到keyWindow事件仍然没有得到处理，那么keyWindow就将事件转发给UIApplication对象，如果仍然不能处理，就将该事件丢弃。
起始于window的初始化对象(hitTestView)，结束于UIApplication对象
所谓的响应者对象就是指可以响应并且处理事件的对象。响应者链就是一系列的响应者对象构成的一个层次结构
第一响应者指的就是当前正在响应事件的对象。
</code></pre><p>#方法签名<br>    方法在声明的时候，方法的名字。<br>    button有3种方法签名<br>    1 没有参数 2 有一个参数UIButton 3 有两个参数 UIButton和 触发事件 参数<br>    手势有两种事件签名<br>    1 没有参数 2 有一个UIGestureRecognizer类型的参数</p>
<p>#main函数的作用<br>    main函数是程序的启动入口，在ios app中，main函数的功能被最小化，他的主要工作交给了UIKit framework</p>
<pre><code>#import &lt;UIKit/UIKit.h&gt;
#import &quot;QYAppDelegate.h&quot;
int main(int argc, char * argv[])
{
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([QYAppDelegate class]));
    }
}
在main函数里面执行了一个UIApplicationMain函数。
argc, argv,直接交给UIapplicationMain进行相关处理即可。第三个参数确定主要应用程序类的名称，如果这个参数是nil，这样就会使用UIApplication类创建对象。第四个参数是程序自定义的代理类名
理解：UIApplicationMain的三件事：
1 根据第三个参数创建UIApplication对象 
2 根据第四个参数确定应用程序的delegate 
3 设置主事件循环(main event loop 可以认为这是一个死循环，他不断的检测事件队列中是否有事件需要处理，当他监听到系统事件时，就会通知UIApplication对象的代理delegate对象)包括application的run loop，同时开始处理事件 当程序加载完毕后调用（只调用一次）application：didFinishLaunchingWithOption:方法。
</code></pre><p>#UIWindow<br>    UIWindow是一种特殊的UIView，通常一个app中只有UIWindow，ios程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的view 最后将控制器的view添加到UIWindow 于是控制器的view就显示屏幕上。也就是说，没有UIWindow，就看不到UI界面<br>    UIWindow的获得：<br>    1 [UIApplication shardApplication].windows 在本应用中打开UIWindow列表，这样就可以接触到应用中的任何一个UIView对象<br>    2 [UIApplication shardApplication].keyWindow 用来接受键盘以及非接触类的消息事件的UIWindow 应用程序中每个时刻只能有一个UIWindow是keyWindow 如果某个UIWindow内部文本框不能输入文字，可能就是这个UIwindow不是keyWindow<br>    3 view.window 获得某个UIView所在的UIWindow<br>    storyBoard加载时<br>    1 会自动创建一个UIWindow对象，<br>    2 加载Main storyBoard 创建箭头所指的视图控制器<br>    3 并将storyBoard箭头所指的控制器设为rootController，并将窗口显示在屏幕上</p>
<p>#UIApplication<br>    UIApplication 对象是应用程序的象征，并且是单例的 [UIApp;icatin shardApplication]可以获得这个单例对象 这个是ios程序启动后创建的第一个对象 并且不允许自己创建该对象<br>    利用UIApplication对象，可以进行一些应用级别的操作<br>    1 设置联网指示器的可见 networkActivityIndicationVisible<br>    2 设置应用程序图标右上角的红色提示数字 applicationIconBadgeNumber(0 代表清除图标右上角的数字)<br>    3 在ios7开始 系统提供了2中管理状态栏的方式 1 通过UIViewController管理 每个UIViewController都可以拥有一个自己的不同的状态栏 2 通过UIApplication管理 一个应用程序的状态栏由他统一管理。<br>    默认的情况下，状态栏都是由UIViewController管理   - （BOOl）preferStatusBarHidden 状态栏的可见性<br>    如果要利用UIApplication来管理状态栏 首先修改info.plist文件<br>    加上row （View controller-based status bar appearance BOOL NO）<br>    4 UIApplication有一个功能十分强大 openURL：方法<br>    UIApplication *app = [UIApplication shardAppliaction];<br>    [app openURL:[NSURL URLWithString:@”tel://10086”]];//打电话<br>    [app openURL:[NSURL URLWithString:@”sms://10086”]];//发短信<br>    [app openURL:[NSURL URLWithString:@”mailto:<a href="mailto://1235@qq.com" target="_blank" rel="noopener">//1235@qq.com</a>“]];//发邮件<br>    [app openURL:[NSURL URLWithStrinf:@”<a href="http://www.baidu.com&quot;]]" target="_blank" rel="noopener">http://www.baidu.com&quot;]]</a>;<br>    打开其他应用app</p>
<p>#程序启动的完整过程<br>    1 首先执行main函数<br>    2 在main函数中调用UIApplication Main函数<br>        创建UIApplication对象<br>        创建UIApplication的Delegate对象<br>    3 delegate对象开始监听系统事件（在非storyBoard的情况下）<br>        1 程序启动完毕后，就会调用代理的<br>        2 application:(UIApplication <em>) didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法<br>        在这个方法中创建UIWindow和rootViewController对象<br>        3 显示窗口<br>    3 根据info.plist获得最主要的storyBoard的文件名，加载最主要的storyboard<br>        1 创建UIWindow<br>        2 创建和设置UIwindow的rootViewController<br>        3 显示窗口</p>
<p>##UIApplication，UIApplication的代理MKDelegate对象，UIWindow，UIViewController之间的关系<br>    UIApplication对象内部有一个代理属性 关联到MKDelegate对象,MKDelegate里面有一个UIwindow属性，关联到UIWindow对象<br>    UIWindow对象通过设置rootViewController属性关联到UIViewController对象，UIViewController的View属性用于显示视图</p>
<p>#退出键盘方法<br>    老方法：谁把键盘叫出来，谁就把键盘放回去<br>    新方法：调用[self.view endEditing:YES]方法 是整个View都不是第一响应者</p>
<p>#info.plist，pch文件 infoPList.string文件<br>    info.plist文件是对整个工程做一些运行期的配置，不能删除，所以在自定义的plist文件命名不能以plist开头，如果修改了info.plist文件，需要先把工程clean 然后再把模拟器中的应用删除<br>    infoPlist.string文件用于本地化 支持对语言环境</p>
<pre><code>pch文件是一个头文件 pch头文件中的内容可以被项目中的其他所有的源文件共享和访问  

作用 1 可以用于存放全局变量（整个项目都用得上的宏） 
2 如果某个头文件要在整个项目中到处使用，可以在pch文件中包含
eg 在pch文件中添加 #define MKLog(...) NSLog(__AV_ARGS__)(固定写法)用MKLog代替NSLog
当改为 #define MKLog(...) //NSLog(__) NSLog(__AV_ARGS__) 相当于把所有的MKLog注释了
3 自动打开后者关闭日志输出功能
应用程序可分为调试阶段和发布阶段，在调试阶段系统（通过检测程序的运行是在真机设配还是模拟器(或者Xcode环境)）会自定义一个叫做DEBUG的宏，当处于发布阶段的时候，DEBUG这个宏会由系统自动删除
#ifdef DEBUG//调试阶段 //很有用
#define MKLog(...) NSLog(__AV_ARGS__)
#else //发布阶段
#define MKLog(...)
#endif
******************************
#ifdef __OBJC__//只有OC文件中的.m 和 .mm 才能使用 __OBJC__这个宏表示只有OC才能使用 所以OC文件里面使用的宏要放在这个宏里面
#import &lt;UIKit/UIKit.h&gt;
#import &lt;Foundation/Foundation.h&gt;
#endif
</code></pre><p>#谓词 predicate<br>    在编程中，经常需要获取一个对象的集合，并通过某些已知条件计算这个集合的值，并保留某些符合条件的对象，删除不满足的条件的对象。 NSPredicate是一种过滤条件,用于指定过滤器的条件。通过创建NSPredicate对象，准确的描述过滤条件，通过谓词筛选对象，判断他们是否于过滤条件匹配<br>    方便1 数组过滤器：通过这种方式不必编写for循环和if语句  -filteredArrayUsingPredicate:是NSArray NSMutableArray数组中的一种类别方法，他将循环遍历数组内容，根据谓词计算每个对象的值，并将值为YES的对象累计添加到一个新数组中。缺点：运行速度没有自己写的代码快<br>    解决谓词中的硬编码问题：方法一：格式说明符 方法2：变量名<br>    predict = [NSPredicate predicateWithFormat:@”engine.horsepower &gt; %d”,50];<br>    predict = [NSPredicate predicateWithFormat:@”name == %@”,@”herbie”]; 通过传参<br>    predict = [NSPredicate predicateWithFormat:@”%K==%@”,@name,@”Herbie”];//改变键路径 只能通过%K的格式符改变键路径<br>    2<br>    predictTemplate = [NSPredicate predicateWithFormat:@”name = $NAME”];<br>    NSDictionary *dict = @{@”NAME”:@”heibie”}<br>    predicate = [predicateTemPlate predicateWithSubstitleVariables:dict];//返回一个新的谓词对象</p>
<p>#正则表达式<br>    正则表达式以用^表示开始 $表示结束 以一个[A-Za-z0-9_+-]表示匹配一个字符 {8}表示匹配8个字符<br>    | 竖直分隔符代表选择。例如“gray|grey”可以匹配grey或gray。</p>
<pre><code>+ 加号代表前面的字符必须至少出现一次。(1次、或多次)。例如,“goo+gle”可以匹 配google、gooogle、goooogle等
? 问号代表前面的字符最多只可以出现一次。(0次、或1次)。例如,“colou?r”可以匹 配color或者colour
* 星号代表前面的字符可以不出现,也可以出现一次或者多次。(0次、或1次、或多 次)。例如,“0*42”可以匹配42、042、0042、00042等。
{n}重复n此
{n,}至少重复 n 此
{n,m}重n 到 m 此
</code></pre><p>#kvc kvo<br>    KVC (key value coding) 是一种协议,(属性的点或者设置实例变量来 直接 更改对象的状态)是一种 间接 更改对象状态的方式.它实现的方法就是使用字符串表示更改的对象状态,如果找不到会调用undefined方法.</p>
<pre><code>KVO 提供了一种机制,当制定对象的属性发生改变后,则对象就会接收到通知,简单的说就是每次指定的被观察的对象的属性被修改后, KVO 就会自动通知相应观察者.
注意:必须使用 set 方法,或者 KVC 的方法修改属性的值,才会引起 KVO 的通知
KVO 是 model 于 controller 之间通信的一种机制.controller 作为观察者,监听 modal 某一属性的改变.
KVO 于 notification 的区别和联系
相同:均可以实现 modal 和 controller 之间的通信
区别: KVO 直接通知 controller, 模型数据的变化,前提是 controller 已经是 modal 的观察者
优点:只通知一个属性的改变,并且属性的改变是由系统通知给 controller, 模型对象不需要发送 post 通知,效率更高,力度更消耗资源更少
notification 可以实现连个对象之间的通信
1 需要通知中心 ,间接地通知 controller, 只要注册即可,
2 如果 modal 发生改变,需要 modal 自己向通知中心发送(调用post方法)通知,再有通知中心再向 controller(前提是已经向通知中心注册) 发送,这个过程力度较大,会通知所有改变
通知(notification 和代理 delegate 的区别)
相同:都能完成对象之间的通信
代理是一对一的(一个对象对应于另外一个对象,并且一个对象只能告诉另外一个对象发生什么事情(单向通信)),通知是多对多的关系(一个对象(通知发布者)可以对应于多个观察者(通知接受者),同时每个观察对象可以同时观察多个对象  )
</code></pre><p>#XML解析<br>    XML 被设计用来结构化(基于树形结构(很重要)),存储以及传输信息,它没有任何行为,不能显示任何信息,区分于HTML<br>    使用 XML json 的目的是为了跨平台<br>    SAX(simple APIs for XML)提供了一种 顺序访问模式 ，当使用SAX分析器解析XML文档进行分析时，会触发一系列的事件，并激活相应的事件处理函数。应用程序通过对这些事件处理函数来实现对XML文件的解析。所以SAX也被成为  事件驱动  接口。由于SAX在对XML文件解析时会触发一系列的处理函数，由于事件触发本身是有时序性的，因此，SAX是一种顺序访问机制，对于已经访问过的部分，不能再倒回去重新工作。SAX在实现时，只是在顺序的检查XML文档中的字节流，判断当前字节是XML语法中的那一部分，是否符合XML语法，再触发相应的事件，事件的处理函数由应用程序自己实现<br>    使用NSXMLParser<br>    优点：对内存占用的少，实现简单，对只需要访问XML文档中的数据而不对文档进行更改的应用程序来说很合适<br>     缺点：缺少灵活性,，效率较低<br>    DOM(document object modal) 文件解析 是利用第三方库GDataXMLNode.h GDataXMLNode.m 在使用第三库的时候在使用DOMXML解析文件是设置一下几项<br>    1 在Header Search Paths 加上/usr/include/libxml2<br>    2 在build Phases中的GCDataXMLNode.m 加上-fno-objc-arc<br>    3 other linkFlag 添上 -lxml2(一套开源的解析框架)<br>    一次性将 XML 文档读入到内存中,并以树形结构存在,可以随意访问任何一个元素<br>    缺点：占用的内存较多</p>
<p>#json<br>    json (javascript object notation)javaScript对象表示法 是轻量级的文本数据交换格式，独立于语言，具有自我描述性，易理解 独立于语言和平台 比XML相比的优点：没有结束标签 更短 读写速度更快 使用数组 不使用保留字,网络数据量消耗小<br>    缺点:可读性差,编码难度大<br>    两种框架<br>    1 NSJsonSerialization ios5.0之后有效<br>    2 jsonKit </p>
<p>#web 服务器<br>    web 服务器也被称为 www服务器,主要功能是可以向发出请求的浏览器提供文档程序.<br>    服务器是一种被动程序,只有当 Internet 上运行其他计算机的浏览器发出请求时,服务器才会响应,常用的服务器有 IIS 和 Apache .<br>    web 服务器是一台在 Internet 上具有独立的 ip 地址的计算机<br>    web 服务器是指驻留在因特网上的某种类型计算机的程序<br>    在 MAC 启动本地的 Apache 服务器 sudo apachectl -k start 重新启动: sudo apachectl -k restart</p>
<p>#post&amp;get<br>    post 和 get 是两种最常用的与服务器进行交互的 HTTP 方法<br>    get 的语义是 获取 指定的URL的资源<br>    将数据按照 variable =value 的形式,添加到 action 所指的 URL 后面,并且两者之间使用?连接,各变量之间使用&amp;连接<br>    缺点:<br>    1 貌似不安全,因为在传输的过程中,数据将被放在请求的 URL 中<br>    2 传输的数据量小,这主要是因为受 URL 的长度限制<br>    post:<br>    post 的语义是 向指定的URL的资源 添加 数据<br>    将数据放在数据体中,按照变量和值向对应的方式,传递到 action 所指向的 URL<br>    优点<br>    1 所有的数据对用户来说都是不可见的<br>    2 可以传输大量数据,上传文件只能是 post<br>    总结:如果从 URL 的角度看的话: get方法是不安全的, post方法是安全的,因为get在传输过程中,数据都放在URL中,但是如果从服务器的角度上讲, get方法是安全的, post方法是不安全的,因为 post方法回向服务器添加数据,而 get 方法只会向服务器获取数据,所以,如果要想服务器进行攻击,只能使用 post 方法</p>
<p>#block<br>    (返回值类型)(^块名字)(参数类型) = ^(参数列表){代码实现};<br>    block 是一种特殊的数据类型,可以将 block 当做比较特殊的对象</p>
<h3 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h3><pre><code>block 可以使用在定义之前声明的局部变量(默认的情况下是只读的)
int i = 10;
void (^myblock)() = ^{
    NSLog(&quot;%d&quot;,i);
};
i = 100;
myblock();
输出结果是 10 
注意:
1 在定义 block 时 ,会在 block 中建立  当前局部变量内容的副本(拷贝), block 中所用的也就是这个副本
2 后续在对该变量的的任何修改,都不会影响 block 中的这个变量的数值
3 如果需要在 block 中保持局部变量的数值变化,需要使用__ block 关键字
4 使用__block 关键字之后,同样可以再 block 中修改变量数值
</code></pre><p>###传递对象</p>
<p>###注意循环引用<br>    @property (nonatomic, strong) NSMutableArray *myBlocks;</p>
<pre><code>#pragma mark 将代码改为调用self的方法
int(^sum)(int, int) = ^(int x, int y) {
    return [self sum:x y:y];
};
[self.myBlocks addObject:sum];

#pragma mark 对象被释放时自动调用
- (void)dealloc
{
    NSLog(@&quot;DemoObj被释放&quot;);
}
self 对 myblocks 强引用 myblock 对sum 强引用 sum 对 self 强引用 产生循环引用的结果就是对象无法释放,由于局部变量默认的都是强引用,离开其所在的作用区域后都会被释放.所以使用__ weak关键字,将局部变量声明为弱引用
__weak DemoObj *weakSelf = self;
int (^int,int) = ^(int,int){
    return [weakSelf sum:x y:y];
};
所以在 block 内部,如果碰到 self, 最好能够思考一下,不要造成循环引用
</code></pre><p>#进程 线程<br>    进程作为分配资源的基本单位,<br>    线程是独立运行和独立调度(有操作系统内核调度)的基本单位.</p>
<p>###进程:<br>    正在运行中的程序,负责程序运行的内存分配,每一个进程都有一个自己独立的虚拟内存空间,进程是一个基本的分配单元,也是一个基本的执行单元,相比较程序,进程是一个动态概念,进程是程序在处理机上的一个执行过程,而程序是一种静态概念,它是一种软件资料在外存上长期有效<br>    要点:<br>    1 进程是一个实体,每个进程都有一个他自己的地址空间,一般情况下,包含数据区域,文本区域,堆和栈.<br>    文本区域存储处理器执行的代码;<br>    数据段存储全局变量,静态变量常亮,还有一些进程执行期间使用的动态分配内存<br>    堆栈区域存储的是进程调用的指令和本地变量<br>    2 进程是一个在内存中运行的程序<br>    进程的缺点:独立的地址造成不同的进程之间的共享状态信息非常困难,为了共享信息,必须显式的使用进程通信机制系统的开销很大, 这就造成了进程之间的通信比较慢,</p>
<p>###线程:<br>    是进程中一个独立的执行路径(控制单元),一个进程中至少包含一个线程,即主线程,通常将耗时的执行路径:eg:网络请求放在其他线程执行.<br>    创建线程的目的就是为了开启一条新的执行路径(在进程中开辟了一个上下文的逻辑流),运行指定的代码,与主线程的代码实现并发运行<br>    多线程优势:<br>    1 充分发挥多核处理器的优势,将不同的线程分配给不同的处理器,<br>    2 将耗时操作分配到其他线程执行,由主线程负责统一更新界面会使程序更加流畅<br>    3 当硬件处理器的数量增加时,程序会运行更快<br>    4 占用的资源很少,所以对他的调度付出的系统开销很小,能跟高效的提高提高系统内多个程序间的并发执行速度<br>    缺点:新建线程会消耗内存空间和 CPU 时间,降低系统性能,多线程技术是为了并发执行多项任务,不会提高单个算法本身的执行效率</p>
<p>###ios 三种多线程技术<br>    1 NSThread (创建简单,管理困难,常使用[NSThread currentThread]跟踪任务所在线程)<br>    2 NSOperation/NSOperationQueue (是使用 GCD 实现的一套 OC 的 API)<br>    3 GCD(Grand Central Dispatch 大中心调度,基于C语言的底层API,用block定义任务,方便,提供了更多的控制能力以及操作队列中不能使用的底层函数)  </p>
<p>#git<br>    git init –bare 创建一个纯代码仓库<br>    git clone ssh:<a href="mailto://git@192.168.1.122" target="_blank" rel="noopener">//git@192.168.1.122</a>/Users/git/Documents/test<br>    git push ssh:<a href="mailto://git@192.168.1.122" target="_blank" rel="noopener">//git@192.168.1.122</a>/Users/git/Documents/test master<br>    git pull </p>
<p>#@property属性的用法<br>    weak(assign):代理\ UI控件<br>    strong(retain)其他对象(除代理\UI控件\字符串)<br>    copy (字符串)<br>    assign 基本数据类型(int float 枚举 结构体 BOOL)</p>
<p>#比较常用的程序架构<br>    当首次使用软件的时候,需要登录为例:<br>        1 下载完成后,运行,先弹出的是用户指引界面,一般式 UIScrollView 和 UIImageView 结合实现,当 UIScrollView 滑动到最后一个界面,通常有一个按钮,点击按钮后进入到登录页面,填写完用户名和密码后,进入主界面<br>        当不是第一次运行APP 的时候,在屏幕上点击 ICNO 图标时,如果记住密码,就直接进入程序主界面,如果没有记住密码的时候,则会重新弹出登录界面,要求用户输入用户名和密码,然后进入主界面.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weibo.com/wangtaoworld/uncategorized/2015/01/17/viewController.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangtao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wt">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/2015/01/17/viewController.html" itemprop="url">viewController</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-17T13:43:19+08:00">
                2015-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-UIViewController生命周期几种方法调用时机"><a href="#1-UIViewController生命周期几种方法调用时机" class="headerlink" title="1.UIViewController生命周期几种方法调用时机"></a>1.UIViewController生命周期几种方法调用时机</h2><ol>
<li>- (id)initWithNibName:(NSString <em>)nibNameOrNil bundle:(NSBundle </em>)nibBundleOrNil;<br>当UIViewController在初始化加载xib文件时，该方法被调用。</li>
<li>- (void)loadView;<br>当每次访问UIViewController的view(比如controller.view,self.view)并且view为nil，该方法就会被调用。</li>
<li>- (void)viewWillUnload; </li>
<li>- (void)viewDidUnload;</li>
<li>- (void)viewDidLoad;<br>不管是通过xib文件还是重写loadView创建UIViewController的view，在view创建完毕后，最终都会调用该方法。</li>
<li>- (void)viewWillAppear:(BOOL)animated;<br>当view将要呈现在UI界面上时会调用该方法。</li>
<li>- (void)viewDidAppear:(BOOL)animated;<br>当view已经完全过渡到屏幕上时会调用该方法。</li>
<li>- (void)viewWillDisappear:(BOOL)animated;<br>当view将要消失，或被覆盖、隐藏时会调用该方法。</li>
<li>- (void)viewDidDisappear:(BOOL)animated;<br>当view已经完全消失，或被覆盖、隐藏时会调用该方法。</li>
</ol>
<h2 id="2-UIViewController-xib的加载过程"><a href="#2-UIViewController-xib的加载过程" class="headerlink" title="2.UIViewController xib的加载过程"></a>2.UIViewController xib的加载过程</h2><p>loadView默认实现就是在自定义的UIViewController类里不重写loadView方法，或者重写后只是在方法里简单实现[super loadView]。默认实现做了如下几个工作：</p>
<ol>
<li>它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view<br> 如果在初始化UIViewController指定了xib文件名，就会根据传入的xib文件名加载对应的xib文件<br> [[UIViewController alloc] initWithNibName:@”ViewController” bundle:nil];<br> 如果没有明显地传xib文件名，就会加载跟UIViewController同名的xib文件<br> [[UIViewController alloc] init]; // 加载UIViewController.xib </li>
<li>如果没有找到相关联的xib文件，就会创建一个空白的UIView，然后赋值给UIViewController的view属性，大致如下：<br> self.view = [[[UIView alloc] initWithFrame:[UIScreen mainScreen].applicationFrame] autorelease];</li>
</ol>
<h2 id="3-几种控制器容器的优缺点"><a href="#3-几种控制器容器的优缺点" class="headerlink" title="3.几种控制器容器的优缺点"></a>3.几种控制器容器的优缺点</h2><h3 id="1-UITabBarController-Tabbar底部标签式-Instagram、微信、微博"><a href="#1-UITabBarController-Tabbar底部标签式-Instagram、微信、微博" class="headerlink" title="1.UITabBarController(Tabbar底部标签式:Instagram、微信、微博)"></a>1.UITabBarController(Tabbar底部标签式:Instagram、微信、微博)</h3><p>UITabBarController作为一种容器适合管理底部标签式（TabBar 如： Instagram、微信、微博）这种结构的APP</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>清楚当前所在的入口位置</li>
<li>轻松在各入口间频繁跳转且不会迷失方向</li>
<li>直接展现最重要入口的内容信息（默认首页）</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>功能入口过多时，该模式显得笨重不实用(超过5个的时候会将其他控制器添加到一个更多界面)</p>
<h3 id="2-UINavigationController-Springboard跳板式-星巴克"><a href="#2-UINavigationController-Springboard跳板式-星巴克" class="headerlink" title="2.UINavigationController (Springboard跳板式:星巴克)"></a>2.UINavigationController (Springboard跳板式:星巴克)</h3><p>UINavigationController作为一种容器适合管理跳板式（SpringBoard 如： 星巴克）这种结构的APP</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>清晰展现各入口</li>
<li>容易记住各入口位置，方便快速找到</li>
</ol>
<h4 id="确定"><a href="#确定" class="headerlink" title="确定"></a>确定</h4><ol>
<li>无法在多入口间灵活跳转，不适合任务操作</li>
<li>容易形成更深的路径</li>
<li>不能直接展现入口内容</li>
<li>不能显示太多入口次级内容</li>
</ol>
<h3 id="3-UINavigationController做整体，融合TabBarController（List-Menu列表式：知乎）"><a href="#3-UINavigationController做整体，融合TabBarController（List-Menu列表式：知乎）" class="headerlink" title="3.UINavigationController做整体，融合TabBarController（List Menu列表式：知乎）"></a>3.UINavigationController做整体，融合TabBarController（List Menu列表式：知乎）</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li>层次展示清晰</li>
<li>可展示内容较长的标题</li>
<li>可展示标题的次级内容</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>同级内容过多时，用户浏览容易产生疲劳</li>
<li>排版灵活性不是很高</li>
<li>只能通过排列顺序、颜色来区分各入口重要程度</li>
</ol>
<h3 id="4-UIScrollvIewController融合pageControl-Carousel旋转木马式-豆瓣同城"><a href="#4-UIScrollvIewController融合pageControl-Carousel旋转木马式-豆瓣同城" class="headerlink" title="4.UIScrollvIewController融合pageControl (Carousel旋转木马式:豆瓣同城)"></a>4.UIScrollvIewController融合pageControl (Carousel旋转木马式:豆瓣同城)</h3><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol>
<li>单页面内容整体性强</li>
<li>线性的浏览方式有顺畅感、方向感</li>
</ol>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>不适合展示过多页面</li>
<li>不能跳跃性地查看间隔的页面，只能按顺序查看相邻的页面</li>
<li>由于各页面内容结构相似，容易忽略后面的内容</li>
</ol>
<h3 id="5-Drawer抽屉式：豆瓣小组"><a href="#5-Drawer抽屉式：豆瓣小组" class="headerlink" title="5. Drawer抽屉式：豆瓣小组"></a>5. Drawer抽屉式：豆瓣小组</h3><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ol>
<li>兼容多种模式（页面内自有组织）</li>
<li>扩展性好</li>
</ol>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>隐藏框架中其他入口</li>
<li>对入口交互的功能可见性(affordance)要求高</li>
<li>对排版要求高</li>
</ol>
<h3 id="6-Plus点聚式：Path"><a href="#6-Plus点聚式：Path" class="headerlink" title="6. Plus点聚式：Path"></a>6. Plus点聚式：Path</h3><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ol>
<li>灵活</li>
<li>展示方式有趣</li>
<li>使界面更开阔</li>
</ol>
<h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>隐藏框架中其他入口</li>
<li>对入口交互的功能可见性(affordance)要求高</li>
</ol>
<h3 id="7-Gallery陈列馆式：多看，豆瓣电影"><a href="#7-Gallery陈列馆式：多看，豆瓣电影" class="headerlink" title="7.Gallery陈列馆式：多看，豆瓣电影"></a>7.Gallery陈列馆式：多看，豆瓣电影</h3><h4 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h4><ol>
<li>直观展现各项内容</li>
<li>方便浏览经常更新的内容</li>
</ol>
<h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>不适合展现顶层入口框架</li>
<li>容易形成界面内容过多，显得杂乱</li>
<li>设计效果容易呆板</li>
</ol>
<h3 id="8-Waterfall瀑布式"><a href="#8-Waterfall瀑布式" class="headerlink" title="8.Waterfall瀑布式"></a>8.Waterfall瀑布式</h3><h4 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h4><ol>
<li>浏览时产生流畅体验</li>
</ol>
<h4 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>缺乏对整体内容的体积感，容易发生空间位置迷失</li>
<li>浏览一段时间后，容易产生疲劳感</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weibo.com/wangtaoworld/uncategorized/2014/11/29/AFNetworking.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangtao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wt">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/2014/11/29/AFNetworking.html" itemprop="url">AFNetworking</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-11-29T21:55:09+08:00">
                2014-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="下载AFNetworking开源代码"><a href="#下载AFNetworking开源代码" class="headerlink" title="下载AFNetworking开源代码"></a>下载AFNetworking开源代码</h2><p>点击链接：<a href="https://github.com/AFNetworking/AFNetworking/archive/master.zip" target="_blank" rel="noopener">AFNetworking</a></p>
<h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><hr>
<h2 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h2><ul>
<li>AFURLConnectioinOperatioin</li>
<li>AFHTTPRequestOperation</li>
<li>AFHTTPRequestOperationManager</li>
</ul>
<h2 id="NSURLSession-iOS-7-Mac-OS-10-9"><a href="#NSURLSession-iOS-7-Mac-OS-10-9" class="headerlink" title="NSURLSession(iOS 7 /Mac OS 10.9)"></a>NSURLSession(iOS 7 /Mac OS 10.9)</h2><ul>
<li>AFURLSessionManager</li>
<li>AFHTTPSessionManager</li>
</ul>
<h2 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h2><ul>
<li><p><strong>AFURLRequestSerialization</strong></p>
<ul>
<li><p>AFHTTPRequestSerialization</p>
</li>
<li><p>AFJSONRequestSerialization</p>
</li>
<li><p>AFPropertyListRequestSerialization</p>
</li>
</ul>
</li>
<li><p><strong>AFURLResponseSerialization</strong></p>
<ul>
<li><p>AFHTTPResponseSerialization</p>
</li>
<li><p>AFJSONResponseSerialization</p>
</li>
<li><p>AFXMLParserResponseSerialization</p>
</li>
<li><p>AFXMLDocumentResponseSerialization (<code>MAC OS X</code>)</p>
</li>
<li><p>AFPropertyListResponseSerialization</p>
</li>
<li><p>AFImageResponseSerializer</p>
</li>
<li><p>AFCompoundResponseSerializer</p>
</li>
</ul>
</li>
</ul>
<h2 id="Additional-Functionality"><a href="#Additional-Functionality" class="headerlink" title="Additional Functionality"></a>Additional Functionality</h2><ul>
<li>AFSecurityPolicy</li>
<li>AFNetworkReachabilityManager</li>
</ul>
<hr>
<h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>#define kBaseURL        @”<a href="http://afnetworking.sinaapp.com&quot;" target="_blank" rel="noopener">http://afnetworking.sinaapp.com&quot;</a></p>
<hr>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requestSerializer 默认是 [AFHTTPRequestSerializer serializer]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">responseSerializer 默认是 [AFJSONResponseSerializer serializer]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="AFHTTPRequestOperation"><a href="#AFHTTPRequestOperation" class="headerlink" title="AFHTTPRequestOperation"></a>AFHTTPRequestOperation</h2><pre><code>NSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_get.json&quot;];
NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;};
NSURLRequest *request = [[AFHTTPRequestSerializer serializer] requestWithMethod:@&quot;GET&quot; URLString:urlStr parameters:parameters error:nil];
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc]initWithRequest:request];
op.responseSerializer = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@&quot;response object : %@&quot;,responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@&quot;Error : %@&quot;,error);
}];
[[NSOperationQueue mainQueue] addOperation:op];
-----------------------------------------------------    
结果：
    Success:
    response object : {
        data =     {
            foo = bar;
        };
        success = 1;
    }
    Error:{
            &quot;errors&quot;:&quot;Parameter error!&quot;,
            &quot;success&quot;:false
    }
-----------------------------------------------------    
</code></pre><h2 id="AFHTTPRequestOperationManager"><a href="#AFHTTPRequestOperationManager" class="headerlink" title="AFHTTPRequestOperationManager"></a>AFHTTPRequestOperationManager</h2><h3 id="GET-Request"><a href="#GET-Request" class="headerlink" title="GET Request"></a><code>GET</code> Request</h3><pre><code>NSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_get.json&quot;];
NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;};
AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
[manager GET:urlStr parameters:parameters success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@&quot;response object : %@&quot;,responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@&quot;Error : %@&quot;,error);
}];
-----------------------------------------------------    
结果：
    Success: 
    response object : {
        data =     {
            foo = bar;
        };
        success = 1;
    }
    Error:{
            &quot;errors&quot;:&quot;Parameter error!&quot;,
            &quot;success&quot;:false
    }
-----------------------------------------------------        
</code></pre><h3 id="POST-URL-Form-Request"><a href="#POST-URL-Form-Request" class="headerlink" title="POST URL-Form-Request"></a><code>POST</code> URL-Form-Request</h3><pre><code>NSString *httpUrlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_post_body_http.json&quot;];
NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;};
AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
[manager POST:httpUrlStr parameters:parameters success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@&quot;response object : %@&quot;,responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@&quot;Error : %@&quot;,error);
}];

NSString *jsonUrlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_post_body_json.json&quot;];
[manager POST:jsonUrlStr parameters:parameters success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@&quot;Response object : %@&quot;,responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@&quot;Error : %@&quot;,error);
}];
-----------------------------------------------------    
结果：
    Success: 
    response object : {
        data =     {
            foo = bar;
        };
        success = 1;
    }
    Error:{
            &quot;errors&quot;:&quot;Parameter error!&quot;,
            &quot;success&quot;:false
    }
-----------------------------------------------------
</code></pre><h3 id="POST-Multi-Part-Request"><a href="#POST-Multi-Part-Request" class="headerlink" title="POST Multi-Part-Request"></a><code>POST</code> Multi-Part-Request</h3><pre><code>NSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;upload2server.json&quot;];
NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;};
AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
[manager POST:urlStr parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
    NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@&quot;b_Aquarius&quot; withExtension:@&quot;jpg&quot;];
    [formData appendPartWithFileURL:fileURL name:@&quot;image&quot; fileName:@&quot;constellation.jpg&quot; mimeType:@&quot;image/jpeg&quot; error:nil];
    fileURL = [[NSBundle mainBundle] URLForResource:@&quot;b_Aries&quot; withExtension:@&quot;png&quot;];
    [formData appendPartWithFileURL:fileURL name:@&quot;image&quot; fileName:@&quot;constellation.png&quot; mimeType:@&quot;image/png&quot; error:nil];
} success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@&quot;Response object : %@&quot;,responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@&quot;Error : %@&quot;,error);
}];
-----------------------------------------------------
结果：
    Success: 
    Response object : {
        data =     (
                    {
                name = &quot;constellation.jpg&quot;;
                url = &quot;http://afnetworking-userdomain.stor.sinaapp.com/constellation.jpg&quot;;
            },
                    {
                name = &quot;constellation.png&quot;;
                url = &quot;http://afnetworking-userdomain.stor.sinaapp.com/constellation.png&quot;;
            }
        );
        success = 1;
    }
-----------------------------------------------------
</code></pre><hr>
<h2 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h2><h3 id="Creating-a-Download-Task"><a href="#Creating-a-Download-Task" class="headerlink" title="Creating a Download Task"></a>Creating a Download Task</h3><p>/#define kDownloadUrl             @”<a href="http://music.baidu.com/data/music/file?link=http://yinyueshiting.baidu.com/data2/music/346495/3464861417179661128.mp3?xcode=91aea20a92711d3d83f3f76a0952eb4b63b77ba183a87289&amp;song_id=346486&quot;" target="_blank" rel="noopener">http://music.baidu.com/data/music/file?link=http://yinyueshiting.baidu.com/data2/music/346495/3464861417179661128.mp3?xcode=91aea20a92711d3d83f3f76a0952eb4b63b77ba183a87289&amp;song_id=346486&quot;</a>  <code>kDownloadUrl 是下载链接</code></p>
<pre><code>NSURL *url = [NSURL URLWithString:kDownloadUrl];
NSURLRequest *request = [NSURLRequest requestWithURL:url];
AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
NSProgress *progress = nil;
NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:&amp;progress destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) {
    NSString *filePath = @&quot;/Users/qingyun/Desktop&quot;;
    NSString *newFielPath = [filePath stringByAppendingPathComponent:response.suggestedFilename];
    NSLog(@&quot;name : %@&quot;,response.suggestedFilename);
    return [NSURL fileURLWithPath:newFielPath];
} completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) {
    if (error) {
        NSLog(@&quot;Error : %@&quot;,error);
    }else{
        NSLog(@&quot;File path : %@&quot;,filePath);
    }
}];
[downloadTask resume];
-----------------------------------------------------
结果：
Success: File path : file:///Users/qingyun/Desktop/Only%20Love.mp3
-----------------------------------------------------
</code></pre><h3 id="Creation-a-Upload-Task"><a href="#Creation-a-Upload-Task" class="headerlink" title="Creation a Upload Task"></a>Creation a Upload Task</h3><pre><code>    NSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;upload2server.json&quot;];
NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:urlStr]];
AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
NSProgress *progress = nil;
NSString *filePath = @&quot;file:///Users/qingyun/Desktop/xml&amp;json.pdf&quot;;
NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithRequest:request fromFile:[NSURL fileURLWithPath:filePath] progress:&amp;progress completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
    if (error) {
        NSLog(@&quot;Error : %@&quot;,error);
    }else{
        NSLog(@&quot;Response objecct : %@&quot;,responseObject);
    }
}];
[uploadTask resume];
-----------------------------------------------------    
结果：
  Success：Response objecct : {
success = 1;
}
-----------------------------------------------------
</code></pre><h3 id="Creation-a-Upload-Task-For-Multi-Part-Request-With-Progress"><a href="#Creation-a-Upload-Task-For-Multi-Part-Request-With-Progress" class="headerlink" title="Creation a Upload Task For Multi-Part Request, With Progress"></a>Creation a Upload Task For Multi-Part Request, With Progress</h3><pre><code>NSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;upload2server.json&quot;];
NSURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@&quot;POST&quot; URLString:urlStr parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
    NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@&quot;b_Cancer&quot; withExtension:@&quot;png&quot;];
    [formData appendPartWithFileURL:fileURL name:@&quot;image&quot; fileName:@&quot;Cancer.png&quot; mimeType:@&quot;image/png&quot; error:nil];

    fileURL = [NSURL URLWithString:@&quot;file://Users/qingyun/Desktop/xml&amp;json.pdf&quot;];
    [formData appendPartWithFileURL:fileURL name:@&quot;image&quot; error:nil];
} error:nil];
NSProgress *progress = nil;
AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithStreamedRequest:request progress:&amp;progress completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
    if (error) {
        NSLog(@&quot;Error : %@&quot;,error);
    }else{
        NSLog(@&quot;Response objecct : %@&quot;,responseObject);
    }
}];
[uploadTask resume];
-----------------------------------------------------    
结果：
Success:Response objecct : {
        data =     (
                    {
                name = &quot;Cancer.png&quot;;
                url = &quot;http://afnetworking-userdomain.stor.sinaapp.com/Cancer.png&quot;;
            }
        );
        success = 1;
    }
-----------------------------------------------------
</code></pre><h3 id="Creation-a-Data-Task"><a href="#Creation-a-Data-Task" class="headerlink" title="Creation a Data Task"></a>Creation a Data Task</h3><pre><code>NSURL *url = [NSURL URLWithString:[kBaseURL stringByAppendingPathComponent:@&quot;response.json&quot;]];
NSURLRequest *request = [NSURLRequest requestWithURL:url];
AFURLSessionManager *manager = [[AFURLSessionManager alloc]initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
    if (error) {
        NSLog(@&quot;Error : %@&quot;,error);
    }else{
        NSLog(@&quot;response object : %@&quot;,responseObject);
    }
}];
[dataTask resume];
-----------------------------------------------------
结果：
Success： response object : {
data = &quot;This is a json data.&quot;;
success = 1;
}
-----------------------------------------------------
</code></pre><hr>
<h2 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h2><h3 id="GET-Request-1"><a href="#GET-Request-1" class="headerlink" title="GET Request"></a><code>GET</code> Request</h3><pre><code>NSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_get.json&quot;];
NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;};
AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
NSURLSessionDataTask *dataTask = [manager GET:urlStr parameters:parameters success:^(NSURLSessionDataTask *task, id responseObject) {
    NSLog(@&quot;response object : %@&quot;,responseObject);
} failure:^(NSURLSessionDataTask *task, NSError *error) {
    NSLog(@&quot;Error : %@&quot;,error);
}];
[dataTask resume];
----------------------------------------------------
结果：
Success :response object : {
    data =     {
        foo = bar;
    };
    success = 1;
}
----------------------------------------------------
</code></pre><h3 id="POSTRequest"><a href="#POSTRequest" class="headerlink" title="POSTRequest"></a><code>POST</code>Request</h3><pre><code>NSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_post_body_http.json&quot;];
NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;};
AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
NSURLSessionDataTask *dataTask = [manager POST:urlStr parameters:parameters success:^(NSURLSessionDataTask *task, id responseObject) {
    NSLog(@&quot;response object : %@&quot;,responseObject);
} failure:^(NSURLSessionDataTask *task, NSError *error) {
    NSLog(@&quot;Error : %@&quot;,error);
}];
[dataTask resume];
-----------------------------------------------------
结果：
Success:response object : {
    data =     {
        foo = bar;
    };
    success = 1;
}
-----------------------------------------------------
</code></pre><h3 id="HEADRequest"><a href="#HEADRequest" class="headerlink" title="HEADRequest"></a><code>HEAD</code>Request</h3><pre><code>NSString *urlStr = [kBaseURL stringByAppendingPathComponent:@&quot;request_post_body_http.json&quot;];
NSDictionary *parameters = @{@&quot;foo&quot;:@&quot;bar&quot;};
AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
NSURLSessionDataTask *dataTask = [manager HEAD:urlStr parameters:parameters success:^(NSURLSessionDataTask *task) {
    NSLog(@&quot;Task : %@&quot;,task);
} failure:^(NSURLSessionDataTask *task, NSError *error) {
    NSLog(@&quot;Task : %@ Error : %@&quot;,task,error);
}];
[dataTask resume];
----------------------------------------------------
结果：
Success： Task : &lt;__NSCFLocalDataTask: 0x8d77b10&gt; { completed }
----------------------------------------------------
</code></pre><hr>
<h2 id="AFNetworkReachabilityManager"><a href="#AFNetworkReachabilityManager" class="headerlink" title="AFNetworkReachabilityManager"></a>AFNetworkReachabilityManager</h2><pre><code>/*
 *AFNetworkReachabilityStatusNotReachable     = 0,
 *AFNetworkReachabilityStatusReachableViaWWAN = 1,
 *AFNetworkReachabilityStatusReachableViaWiFi = 2
 */
NSArray *array = @[@&quot;不可达&quot;,@&quot;2G/3G/4G&quot;,@&quot;wi-fi&quot;];

[AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];
[self.manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
    UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@&quot;网络检测&quot; message:[NSString stringWithFormat:@&quot;%@&quot;,array[status]] delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil, nil];
    [alert show];

}];

-----
[manager startMonitoring];
[manager stopMonitoring];
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weibo.com/wangtaoworld/uncategorized/2014/11/27/XML-JSON.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangtao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wt">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/2014/11/27/XML-JSON.html" itemprop="url">XML_JSON</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-11-27T21:16:13+08:00">
                2014-11-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h3><ol>
<li><p>创建XML解析对象</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"bookstore"</span> withExternsion:<span class="string">@"xml"</span>];</span><br><span class="line"><span class="built_in">NSXMLParser</span> *parser = [][<span class="built_in">NSXMLParser</span> alloc]initWithContentsOfURL:url];</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置XMLParser 对象的delegate</p>
 <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.delegate = self<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用delegate的fangf</p>
 <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">parserDidStartDocument:</span>(NSXMLParser *)parser</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当时开始解析的时候条用该方法，通常在这个方法里，		    		    创建模型数组</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">parser:</span>(NSXMLParser *)parser <span class="string">didStartElement:</span>(NSString *)elementName <span class="string">namespaceURI:</span>(NSString *)namespaceURI <span class="string">qualifiedName:</span>(NSString *)qName <span class="string">attributes:</span>(NSDictionary *)attributeDict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当开始解析，遇到元素的开始标签时，回调用这个方法，通常在这个方法里，创建模型对象，或解析标签中得属性并保存在模型对象中</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">parser:</span>(NSXMLParser *)parser <span class="string">foundCharacters:</span>(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当解析到xml标签的文本内容时，回调用这个方法，通常在这个方法里，暂存解析到的文本内容</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">parser:</span>(NSXMLParser *)parser <span class="string">didEndElement:</span>(NSString *)elementName <span class="string">namespaceURI:</span>(NSString *)namespaceURI <span class="string">qualifiedName:</span>(NSString *)qName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当解析xml内容遇到结束标签时，回调用这个方法，通常在这个方法里，需要将模型对象保存到数组中或把标签对应的文本内容解析出来，保存在模型对象中。（通过KVC赋值）</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">parserDidEndDocument:</span>(NSXMLParser *)parser</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//当整个xml解析完成条用这个方法，可以完成其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="DOM解析"><a href="#DOM解析" class="headerlink" title="DOM解析"></a>DOM解析</h3><p>以下以GDataXMLNode为例：</p>
<pre><code><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">￼* <span class="tag">&lt;节点&gt;</span> (GDataXMLNode)￼* 根据 DOM,<span class="keyword">XML</span> <span class="title">⽂文档中的每个成分都是⼀一个节点。￼* DOM</span> 是这样规定的:￼* 整个⽂文档是⼀一个⽂文档节点￼* 每个 <span class="keyword">XML</span> <span class="title">标签是⼀一个元素节点￼* 包含在 XML</span> 元素中的⽂文本是⽂文本节点￼* 每⼀一个 <span class="keyword">XML</span> <span class="title">属性是⼀一个属性节点￼* 注释属于注释节点￼￼</span></span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>导入第三方库</p>
 <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">导入第三方库时，首先编译检查是否可用，（头文件是否编译通过，头文件是否需要导入头文件路径，是否使用非ARC环境）</span><br><span class="line">1. 头文件编译未通过，添加文件搜索路径，头文件为系统头文件时：在<span class="keyword">Build</span> setting下的Header Search Paths 添加/usr/<span class="keyword">include</span>/libxml2</span><br><span class="line">	头文件为用户头文件时：在<span class="keyword">Build</span> setting下的<span class="keyword">User</span> Header Search Paths 添加/usr/<span class="keyword">include</span>/libxml2</span><br><span class="line"><span class="number">2.</span> 在<span class="keyword">Build</span> Phases 下的Link <span class="keyword">Binary</span> <span class="keyword">With</span> Libraries 添加libxml2.dylib,链接的动态库</span><br><span class="line"><span class="number">3.</span> 在<span class="keyword">Build</span> Phases 下的Compile Sources 将导入的编译文件设置为非ARC 即添加 -fno-objc-arc即可</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建GDataXMLDocument对象</p>
 <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSData *data = [[NSBundle mainBundle] <span class="string">URLForResource:</span>@<span class="string">"bokstore"</span> <span class="string">withExternsion:</span><span class="string">"xml"</span>];</span><br><span class="line">GDataXMLDocument *document = [[GDataXMLDocument alloc]<span class="string">initWithData:</span>data <span class="string">options:</span><span class="number">0</span> <span class="string">error:</span>nil];</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取根元素rootElement</p>
 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[document rootElement]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由根元素，可以获取到根元素下的子元素，以及对子元素的属性赋值；</p>
 <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取子元素的方法：</span><br><span class="line"><span class="bullet">- </span>(NSArray <span class="strong">*)elementsForName:(NSString *</span>)name;</span><br><span class="line">获取子元素属性的方法：</span><br><span class="line"><span class="bullet">- </span>(GDataXMLNode <span class="strong">*)attributeForName:(NSString *</span>)name;</span><br><span class="line">将GDataXMLNode对象转换为NSString对象的方法：</span><br><span class="line"><span class="bullet">- </span>(NSString <span class="strong">*)stringValue;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (GDataXMLElement *element in elements) &#123;￼// 创建图书对象￼YMBook *book = <span class="comment">[<span class="comment">[YMBook alloc]</span> init]</span>;￼// 根据属性名字,解析book元素的属性值￼book.category = <span class="comment">[<span class="comment">[element attributeForName:kCategory]</span>￼stringValue]</span>;￼// 解析book的⼦子元素包含的⽂文本内容及其⼦子元素的属性￼<span class="comment">[0]</span>;GDataXMLElement *titleElement = <span class="comment">[element elementsForName:kTitle]</span>￼￼book.title = <span class="comment">[titleElement stringValue]</span>;￼book.lang = <span class="comment">[<span class="comment">[titleElement attributeForName:kLanguage]</span>￼stringValue]</span>;￼GDataXMLElement *authorElement = <span class="comment">[element￼elementsForName:kAuthor]</span><span class="comment">[0]</span>;￼book.author = <span class="comment">[authorElement stringValue]</span>;￼GDataXMLElement *yearElement = <span class="comment">[element elementsForName:kYear]</span>￼<span class="comment">[0]</span>;￼book.year = <span class="comment">[yearElement stringValue]</span>;￼GDataXMLElement *priceElement = <span class="comment">[element elementsForName:kPrice]</span>￼<span class="comment">[0]</span>;￼book.price = <span class="comment">[priceElement stringValue]</span>;￼    <span class="comment">[_bookStore addObject:book]</span>;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>1.数据分类<br>从结构上看,所有的数据(data)最终都可以分解成三种类型:</p>
<pre><code>- 第一种类型是标量(scalar),也就是一个单独的字符串(string)或数字 (numbers),比如&quot;北京&quot;这个单独的词 

- 第二种类型是序列(sequence),也就是若干个相关的数据按照一定顺序并列在一 起,又叫做数组(array)或列表(List),比如&quot;北京,上海&quot; 

- 第三种类型是映射(mapping),也就是一个名/值对(Name/value),即数据有一个 名称,还有一个与之相对应的值,这又称作散列(hash)或字典(dictionary),比 如&quot;首都:北京&quot;
</code></pre><p>Douglas Crockford发明了JSON,Json的规定非常简单:</p>
<ol>
<li><p>并列的数据之间用逗号(“, “)分隔 </p>
</li>
<li><p>映射用冒号(“: “)表示</p>
</li>
<li><p>并列数据的集合(数组)用方括号(“[]”)表示 </p>
</li>
<li><p>映射的集合(对象)用大括号(“{}”)表示</p>
</li>
</ol>
<p>比如,下面这句话:</p>
<p>“”北京市的⾯面积为16800平⽅方公⾥里,常住⼈人⼜⼝口1600万⼈人。上海市的⾯面积为6400平⽅方 公⾥里,常住⼈人⼜⼝口1800万。”</p>
<p>写成JSON格式就是这样:</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">￼  &#123;<span class="string">"城市"</span>:<span class="string">"北京"</span>,<span class="string">"⾯面积"</span>:<span class="number">16800</span>,<span class="string">"⼈人⼝口"</span>:<span class="number">1600</span>&#125;,￼  &#123;<span class="string">"城市"</span>:<span class="string">"上海"</span>,<span class="string">"⾯面积</span></span><br><span class="line">]</span><br><span class="line">```如果事先知道数据的结构,上面的写法还可以进一步简化:</span><br></pre></td></tr></table></figure>
<p>[<br>    [“北京”,16800,1600],<br>    [“上海”,6400,1800]<br>]</p>
<pre><code>&lt;www.json.org/json-zh.htm&gt;


### NSJSONSerialization

    <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	- 反序列</span><br><span class="line">	￼+ (<span class="keyword">id</span>)JSONObjectWithData:(<span class="built_in">NSData</span> *)data	                     error:(<span class="built_in">NSError</span> **)error	￼options:(<span class="built_in">NSJSONReadingOptions</span>)opt	￼error:(<span class="built_in">NSError</span> **)error</span><br><span class="line">	- 序列化	￼+ (<span class="built_in">NSData</span> *)dataWithJSONObject:(<span class="keyword">id</span>)obj	options:(<span class="built_in">NSJSONWritingOptions</span>)opt	￼￼</span><br><span class="line">	```<span class="meta">### JSONKit</span></span><br><span class="line"><span class="number">1.</span> 需要导入第三方库</span><br><span class="line">使用: `-fno-objc-arc`</span><br><span class="line">序列化: **<span class="built_in">NSArray</span>** **<span class="built_in">NSDictionary</span>** **<span class="built_in">NSString</span>**￼</span><br></pre></td></tr></table></figure>

    – JSONData
    ￼– JSONDataWithOptions:includeQuotes:error:
    ￼-
    ￼JSONDataWithOptions:serializeUnsupportedClassesUsingDelegate:selector:error:
    ￼- JSONDataWithOptions:serializeUnsupportedClassesUsingBlock:error:
    ￼– JSONString
    ￼– JSONStringWithOptions:includeQuotes:error:
    ￼-
    ￼JSONStringWithOptions:serializeUnsupportedClassesUsingDelegate:selector:erro
    ￼r:
    ￼– JSONStringWithOptions:serializeUnsupportedClassesUsingBlock:error:
    ￼
    <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反序列化：*<span class="strong">*NSData*</span>* *<span class="strong">*NSString*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure>

    – objectFromJSONData
    ￼– objectFromJSONDataWithParseOptions:
    ￼– objectFromJSONDataWithParseOptions:error:
    ￼– mutableObjectFromJSONData
    ￼– mutableObjectFromJSONDataWithParseOptions:
    ￼– mutableObjectFromJSONDataWithParseOptions:error:
    ￼– objectFromJSONString
    ￼– objectFromJSONStringWithParseOptions:
    ￼– objectFromJSONStringWithParseOptions:error:
    ￼– mutableObjectFromJSONString
    ￼– mutableObjectFromJSONStringWithParseOptions:
    ￼– mutableObjectFromJSONStringWithParseOptions:error:
    ￼
</code></pre><p>￼<br>￼</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weibo.com/wangtaoworld/uncategorized/2014/11/24/1124.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangtao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wt">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/2014/11/24/1124.html" itemprop="url">1124</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-11-24T09:36:56+08:00">
                2014-11-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>蹦，崩</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weibo.com/wangtaoworld/uncategorized/2014/11/20/NTFS-read-write.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangtao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wt">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/2014/11/20/NTFS-read-write.html" itemprop="url">NTFS read-write</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-11-20T09:06:21+08:00">
                2014-11-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>********************************************************************
    1:&gt;&gt;&gt;  sudo mount | grep ntfs  &lt;&lt;&lt;
    2:会得到如下路径，第3条的命令根据该路径而变化
    &quot;/dev/disk1s1 on /Volumes/半片残枫 (ntfs, local, nodev, nosuid, read-only, noowners)&quot;
    3:&gt;&gt;&gt;  sudo umount /dev/disk1s1  &lt;&lt;&lt;
    4:&gt;&gt;&gt;  sudo mkdir -p /Volumes/wto  &lt;&lt;&lt;
    5:&gt;&gt;&gt;  sudo mount_ntfs -o rw,auto,nobrowse,noowners,noatime /dev/disk1s1 /Volumes/wto  &lt;&lt;&lt;
    //网上代码    &gt;&gt;&gt;  sudo mount_ntfs -o rw,auto,nobrowse,noowners,noatime  /dev/disk0s1 /Volumes/Win7boot
       &lt;&lt;&lt;
    6:&gt;&gt;&gt;  cd /Volumes  &lt;&lt;&lt;
    7:&gt;&gt;&gt;  open .  &lt;&lt;&lt;
    8:推出硬盘命令
    &gt;&gt;&gt;  sudo umount /Volumes/wto  &lt;&lt;&lt;
    或者在Finder中右键推出
    *****此方法需要每次插入硬盘时执行该部分命令
********************************************************************
    http://www.memacx.com/forum.php?mod=viewthread&amp;tid=5482
    //
    在root下使用(建议使用此条)
    &gt;&gt;&gt;   vi ~/.bashrc   &lt;&lt;&lt;
    编辑添加： export EDITOR=vim
    网上&gt;&gt;&gt;  echo export EDITOR=/usr/bin/vim &gt;&gt; ~/.bashrc
    或者
    //直接执行
    &gt;&gt;&gt;  export EDITOR=vim
    或者
    //执行
    &gt;&gt;&gt;  EDITOR=vim  &lt;&lt;&lt;
    &gt;&gt;&gt;  export EDITOR  &lt;&lt;&lt;

保存后即可和vim编译器一样编辑 /etc/fstab 下的内容：vim /etc/fstab,
也就是可以直接执行 &gt;&gt;&gt;&gt;   vifs  &lt;&lt;&lt;命令
然后直接像在vim中一样直接编辑添加
//
LABEL=半片残枫 none ntfs rw,nobrowse,noatime,nosuid
//或
LABEL=半片残枫 none ntfs rw,nobrowse,noowners,noatime,nosuid
//
******此方法即可在以后每次开机时自动执行该命令，自动会挂载NTFS格式硬盘半片残枫为读写格式的
********************************************************************
    /////////////////////////////////////////////////////////////
    尤明大牛给的建议：
    //1：
    先执行
    &gt;&gt;&gt;   sudo mount_ntfs -o rw,auto.nobrowse,noowners,noatime /dev/disk1s1 /Volumes/disk   &lt;&lt;&lt;
    //其中disk为自己在  /Volmes/  下创建的文件，
    //disk1s1为执行&gt;&gt;&gt;  sudo mount | grep ntfs  &lt;&lt;&lt;后查看到的文件
    //此方法需要每次插入硬盘时都需要执行该部分命令
    //2：
    不行的话就在   /etc/fstab 下
    vi fsatb
    //
    添加
    LABEL=半片残枫 none ntfs rw
    //
    此方法即可每次开机自动将NTFS格式的硬盘挂载为读写格式的
    ///////////////////////////////////////////////////////////////
**********************************************************************
    //链接
    一般情况下，ubuntu终端下的默认编辑器为nano，我们直接编辑某个文件，默认就会打开nano。比如我们输入“crontab -e“的时候默认会打开nano编辑器。
    对于熟悉VIM的朋友来说，都希望默认编辑器能使用vim，那么我们就需要修改ubuntu的默认编辑器。
    修改ubuntu默认编辑器有三种方法：
    一、直接在终端输入：

echo export EDITOR=/usr/bin/vim &gt;&gt; ~/.bashrc
二、使用系统管理工具update-alternatives来修改
在终端输入：
update-alternatives --config editor
然后选择vim.basic这项即可
三、如果系统中只剩下nano和vim两个编辑器，这个时候我们如果完全删除nano，那么系统会默认选择vim为默认编辑器
在终端输入删除nano编辑器的命令：

sudo apt-get remove nano

修改完成之后我们输入：

crontab -e
看一看出现的是不是大家喜欢的vim编辑器呢。


改变默认的程序来运行

比如说，想给PDF文件换个默认的阅读工具，怎么弄呢？
　　随便找个PDF文件，右击-&gt;使用其它程序打开，这样是可以选择不同的阅读器，可是如何指定为默认的阅读器呢？
　　ubuntu中有两个文件，跟文件的默认打开方式有关：
　　1./etc/gnome/defaults.list 保存了全局的打开方式
　　2.~/.local/share/applications/mimeapps.list 保存了个人的打开方式

    当两着有冲突，则优先采用局部的个人设置。举个例子：
　　application/pdf=Foxit-Reader.desktop;
    这样，系统就默认使用Foxit Reader作为PDF默认的阅读器，而不是系统自带的evince。注意格式，文件名要写对，后面有分号。
　　文件名怎么写呢？其实，通过“右击-&gt;使用其它程序打开”，就会在mimeapps.list，产生一条记录，该记录就会显示你选中程序的文件名，这下该知道怎么做了吧
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weibo.com/wangtaoworld/uncategorized/2014/11/17/MacBook-Pro.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangtao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wt">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/2014/11/17/MacBook-Pro.html" itemprop="url">MacBook Pro</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-11-17T23:27:11+08:00">
                2014-11-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我的MacBook Pro，哈哈，不习惯没有鼠标的操作，尽快适应吧，嘿嘿</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weibo.com/wangtaoworld/uncategorized/2014/11/16/hexo.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangtao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wt">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/uncategorized/2014/11/16/hexo.html" itemprop="url">hexo指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-11-16T21:53:25+08:00">
                2014-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="hexo指南"><a href="#hexo指南" class="headerlink" title="####hexo指南"></a>####hexo指南</h2><pre><code>//
brew install   &gt;&gt;&gt;&gt;   brew.sh网站上
//
ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
//
brew install wget
//
wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh
// 或者
wget -qO- https://raw.github.com/creationix/nvm/master/install.sh
//
vi ~/.zshrc  &gt;&gt;&gt;将Users/后面改为wangtao
//
hostname
//
users
//
source ~/.zshrc
//
which nvm
//
nvm install 0.10
//
npm install -g hexo
//
hexo init hexo 
//
cd hexo
//
npm install  &gt;&gt;&gt;初始化
//
hexo g
//vi 
hexo s
//
//
hehe
//
haha
//
hiahia
//
heihei
//
//

//
//
在 /Users/wangtao下 
///   cd .nvm  
///   cd vo.10.33   
///   cd bin   
///   ls -a  查看是否有hexo node npm，有的话，就拷贝pwd目录

/Users/wangtao/.nvm/v0.10.33/bin

//
在 /Users/wangtao  下vi  .zsfrc   &lt;&lt;&lt;
export PATH=/Users/wangtao/.nvm/v0.10.33/bin:$PATH
//
在/Users/wangtao/hexo   下vi _config.yml
//
将title:        更改
//
deploy:
  type: github
  repository: https://github.com/wangtaoios/wangtaoios.github.io.git
  branch: master
//

//
hexo new &quot;biaoti&quot;
//
mou /Users/qingyun/hexo/source/_posts/biaoti.md
//
hexo g -d   ==   hexo g  和 hexo s
// 
//
hexo g -d
//
在vi  .gitconfih
//
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wangtao</p>
              <p class="site-description motion-element" itemprop="description">技术交流</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangtao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
